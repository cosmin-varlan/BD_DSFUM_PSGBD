<p>= Structuri de control =</p>

<p>Pentru ca un limbaj să fie considerat limbaj de programare, pe lângă operaţia de atribuire trebuie să permită evaluarea de condiţii (şi executarea unui cod diferit în funcţie de rezultat) şi crearea de bucle. </p>

<h2> Structuri de control conditionale </h2>

<p>În PL/SQL verificarea condiţiilor (pot fi utilizate şi funcţii care intorc o valoarea booleană - ca de exemplu between, like, etc.) este realizată de comanda IF - THEN - ELSE având următoarea structură:</p>

<pre><code class="language-sql">IF condiţie THEN 
         secvenţă de instrucţiuni ce vor fi rulate în cazul în care condiţia este îndeplinită;
   ELSE
         secvenţă de instrucţiuni ce vor fi executate în cazul în care condiţia nu este îndeplinită;
END IF; 

<p>La fel ca şi în alte limbaje de programare, secţiunea ELSE împreună cu blocul de instrucţiuni arondat ei pot să lipsească.</p>
<p>Iata un exemplu al utilizării instrucţiunii IF-THEN-ELSE :</p>


<pre><code class="language-sql">set serveroutput on;
accept i_numar prompt "Please enter your number: "; 
DECLARE
   v_numar NUMBER(5);
   i_numar NUMBER(5);
BEGIN   
   v_numar := &i_numar;
   IF (v_numar MOD 2 = 0)
      THEN 
        DBMS_OUTPUT.PUT_LINE('Numarul '||v_numar||' este par.');
      ELSE
        DBMS_OUTPUT.PUT_LINE('Numarul '||v_numar||' este impar.');
   END IF;
END;  

<p>Dacă în secţiunea ELSE se doreşte testarea unei noi condiţii se poate utiliza comanda ELSIF (care la rândul ei va fi urmată de o secţiune THEN şi apoi de una ELSE/ELSIF). Atunci când sunt utilizate mai multe secţiuni de tipul ELSIF (atenţie, nu ELSEIF), în final se va pune o singură dată comanda ce identifică încheierea ultimului bloc (END IF). Spre exemplu, dacă dorim să testăm apartenenţa unui număr la un anumit interval de numere putem recurge la codul:</p>

<pre><code class="language-sql">DECLARE
   v_numar NUMBER(5) := 50;
BEGIN
   IF (v_numar < 10)
       THEN
           DBMS_OUTPUT.PUT_LINE('Numarul este mai mic decat 10');
       ELSIF (v_numar > 80) THEN
           DBMS_OUTPUT.PUT_LINE('Numarul este mai mare decat 80');
       ELSE
           DBMS_OUTPUT.PUT_LINE('Numarul este in intervalul [10,80]');  
   END IF;

<p>În cazul în care valoarea unei variabile este comparată cu mai multe valori posibile, se poate utiliza instrucţiunea CASE. Pe lângă compararea variabilei cu valorile predefinite, instrucţiunea de control CASE permite şi executarea unui cod default în cazul în care variabila nu are nici una dintre valorile aşteptate:</p>

<pre><code class="language-sql">DECLARE
   numar NUMBER := 5;
BEGIN
   CASE (numar)
       WHEN 1 THEN DBMS_OUTPUT.PUT_LINE('Primul numar natural nenul.');
       WHEN 2 THEN DBMS_OUTPUT.PUT_LINE('Primul numar natural par.');
       ELSE
           DBMS_OUTPUT.PUT_LINE('Un numar mai mare sau egal cu 3');
   END CASE;

<p>Vă aminitiţi ce facea funcţia DECODE în SQL ? Această funcţie poate fi simulată cu o instrucţiune de tip CASE. Executaţi următoarea comandă SELECT:</p>

<pre><code class="language-sql">SELECT nume, prenume,
CASE bursa
   WHEN 450 THEN 'Patru sute si cinci zeci'
   WHEN 350 THEN 'Trei sute si cinci zeci'
   WHEN 250 THEN 'Doua sute si cinci zeci'
   ELSE 'Fara bursa'
END
FROM studenti;
</code></pre>


<p>Comanda CASE poate să nu aibă un operand iniţial caz în care valorile ce urmează după WHEN trebuie să fie de tip boolean:</p>

<pre><code class="language-sql">SELECT nume, prenume,
CASE 
   WHEN bursa>300 THEN 'Bogat'      
   ELSE 'Sarac'
END
FROM studenti;
</code></pre>


<h2> Bucle în PLSQL </h2>

<p>Buclele în PLSQL pot fi cu condiţie iniţială, cu condiţie finală şi care se vor repeta de un anumit număr de paşi (de tip for). Bucla cu condiţie iniţială este realizată prin utilizarea WHILE(condiţie) ... END LOOP, cea cu condiţie finală poate fi obţinută prin LOOP ... END LOOP (de fapt va produce o buclă infinită din care se poate ieşi cu o instrucţiune te tip EXIT iar bucla ce se va repeta de un anumit număr de paşi se realizează cu instrucţiunea FOR contor IN initia..final LOOP ... END LOOP;. Iată câteva exemple:</p>

<p>Primul exemplu va fi pentru bucla de tip WHILE:</p>


<pre><code class="language-sql">set serveroutput on;
DECLARE
   v_contor INTEGER := 0;
BEGIN
   WHILE (v_contor < 10) LOOP       
       v_contor := v_contor + 1;
       DBMS_OUTPUT.PUT_LINE(v_contor);  
   END LOOP;

<p>Exemplul adaptat pentru structura LOOP împreună cu comanda de ieşire din buclă (comanda EXIT poate fi aplicată pentru orice structură repetitivă şi are forma EXIT WHEN (condiţie)  sau EXIT etichetă WHEN (condiţie) atunci când sunt utilizate mai multe cicluri impricate şi se doreşte ieşirea dintr-un anumit ciclu - de exemplu cel exterior.):</p>

<pre><code class="language-sql">set serveroutput on;
DECLARE
   v_contor INTEGER := 0;
BEGIN
   LOOP
       v_contor := v_contor + 1;
       DBMS_OUTPUT.PUT_LINE(v_contor);  
       EXIT WHEN v_contor = 10;
   END LOOP;

<p>Ultima metodă de a realiza o structură repetitivă în PLSQL este utilizând comanda FOR. Un exemplu în acest sens:</p>

<pre><code class="language-sql">set serveroutput on;
DECLARE
   v_contor INTEGER := 0;
BEGIN
   FOR v_contor IN 1..10 LOOP
       DBMS_OUTPUT.PUT_LINE(v_contor);  
   END LOOP;

<p>În cazul în care se doreşte parcurgerea în sens invers a valorilor din intervalul precizat, de va utiliza cuvântul REVERSE imediat după utilizarea lui IN (e.g. FOR v_contor IN REVERSE 1..10 LOOP ).</p>

<p>Comanda EXIT poate fi invocată oricând în interiorul unei structuri repetitive pentru a forţa ieşirea din aceasta. În cazul în care doua structuri repetitive sunt imbricate şi se doreşte ieşirea din ambele structuri, prima structură repetitivă va fi etichetată:</p>


<pre><code class="language-sql">set serveroutput on;
DECLARE
   v_contor1 INTEGER;
   v_contor2 INTEGER;
BEGIN
   <<eticheta>>
   FOR v_contor1 IN 1..5 LOOP
       FOR v_contor2 IN 10..20 LOOP
           DBMS_OUTPUT.PUT_LINE(v_contor1||'-'||v_contor2);  
           EXIT eticheta WHEN ((v_contor1=3) AND (v_contor2=17));
       END LOOP;
   END LOOP;

<p>Comanda CONTINUE are rolul de a sări peste restul codului rămas în buclă şi de a îcepe o nouă iteraţie. De exemplu, în codul de mai sus, dacă dorim să nu fie afişată linia în care apare combinaţia 3-13, putem să introducem înaintea liniei de afişare următoarea linie:</p>

<pre><code class="language-sql">CONTINUE WHEN ((v_contor1=3) AND (v_contor2=13));
</code></pre>


<p>Puteţi face în aşa fel încât să nu fie afişată ultima linie ? Cea cu combinaţia 3-17 ?</p>

<p>O ultimă comandă ce poate afecta o buclă este GOTO. Aceasta face saltul la o anumită etichetă. Se poate iesi forţat din buclă utilizând GOTO, urmatorul exemplu este doar un simplu salt</p>

<pre><code class="language-sql">set serveroutput on;
BEGIN
   GOTO eticheta;
   DBMS_OUTPUT.PUT_LINE('Nu se va afisa.');
   <<eticheta>>         
   DBMS_OUTPUT.PUT_LINE('Se va afisa.');

<p>Puteţi utiliza două instrucţiuni GOTO pentru a emula o structură repetitivă ?</p>

<p>= Utilizarea cursoarelor =</p>

<p>Memoria în care este păstrată o interogare împreună cu datele pe care le utilizează se numeşte cursor. Cursorul poate fi implicit (utilizatorul nu are acces la el - de exemplu nu ştiţi ce se petrece în memoria serverului atunci când executaţi o comanda SQL) sau explicit (care este definit şi utilizat de către un programator PL/SQL special pentru a parcurge datele selectate una câte una sau pentru a le manipula).</p>

<h2> Cursoare implicite </h2>

<p>Deşi programatorul nu are acces direct la zona de memorie în care se află un cursor implicit, acesta poate obţine anumite informaţii despre execuţia interogării (relative la numărul de rânduri procesate) prin intermediul a trei atribute specifice. Cele trei atribute ale unui cursor implicit ce pot fi utilizate de programator sunt SQL%FOUND, SQL%NOTFOUND, SQL%ROWCOUNT.</p>

<p>Să considerăm următorul cod PL/SQL care modifică bursa tutror studenţilor cu o bursa având valoarea mai mare decât 300 (şi îi adaugă 10 Ron):</p>

<pre><code class="language-sql">DECLARE
   v_randuri INTEGER;
BEGIN  
   UPDATE studenti set bursa = bursa + 10 WHERE bursa>300;
   IF(SQL%FOUND) 
      THEN
         DBMS_OUTPUT.PUT_LINE('Am marit bursa la ' || SQL%ROWCOUNT || ' studenti.');
      ELSE
         DBMS_OUTPUT.PUT_LINE('Nimanui nu i s-a marit bursa.');
    END IF;

<h2> Cursoare explicite </h2>

<p>Cursoarele explicite sunt declarate şi utilizate în scripturile PL/SQL. Ele sunt utilizate atunci când interogările pe care le efectuăm asupra bazei de date vor returna mai mult de un singur rând (altfel valorile ar putea fi reţinute în variabile şi utilizate în acest mod) şi permit procesarea informaţiilor din rezultat linie cu linie.</p>

<p>Paşii pe care trebuie să îi urmăm când utilizăm un cursor sunt: declararea, deschiderea, preluarea de linii, închiderea cursorului.</p>

<p>Un cursor explicit se declară în zona de declaraţii a scriptului PL/SQL (deşi cursoare explicite pot fi utilizate şi direct în FOR). Pentru declarare se va utiliza următorul format:</p>


<pre><code class="language-sql">DECLARE
   CURSOR   nume_cursor  IS  comanda_select;

<p>În această construcţie, comanda_select este orice comandă de tip SELECT (poate conţine JOIN, GROUP BY, ORDER BY etc.). In cazul in care comanda select contine variabile PL/SQL acestea vor fi declarate înaintea utilizării lor în definiţia cursorului.</p>

<p>Deschiderea cursorului se realizează in secţiunea de cod aflată între comenzile BEGIN şi END. Acest lucru se face cu comanda OPEN urmată de numele cursorului şi are ca efect alocarea de memorie pentru datele ce vor fi selectate de comanda select, executarea comenzii select şi introducerea datelor în memorie, poziţionarea pointerului pe primul rând returnat.</p>


<pre><code class="language-sql">
În continuare, într-o secţiune LOOP (pentru că avem mai multe linii şi vrem ca fiecare să fie prelucrată individual), se apelează comanda FETCH urmată de numele cursorului, de cuvântul cheie INTO şi apoi de variabilele ce vor reţine valorile. Executarea comenzii FETCH va avea ca efect (pe lângă atribuirea variabilelor cu valorile din cursor) trecerea la următoarea linie returnată de comanda select. Din categoria "Bune practici",înainte de a intra în LOOP sau de a face primul fetch, aţi putea testa dacă selectul a returnat măcar o linie.

 <nowiki>FECTH nume_cursor INTO v_var1, v_var2, v_var3;
</code></pre>


<p>Pentru a testa daca s-a ajuns la ultimul rând (util pentru a ieşi din buclă) se va utiliza atributul NOTFOUND specific cursoarelor explicite. Valoarea atributului nume_cursor%NOTFOUND este aşadar true atunci când operaţia FETCH nu a mai fost capabilă să returneze informaţii din cursor. Acesta este, probabil,  momentul  în care se doreşte părăsirea buclei:</p>

<pre><code class="language-sql">
În final, după ce s-a ieşit din buclă, cursorul va fi închis prin executarea comenzii CLOSE urmată de numele cursorului. Dacă se va utiliza din nou comanda OPEN, cursorul va fi redeschis, comanda select va fi re-executată şi va fi iarăşi poziţionat pe prima linie returnată de comanda select utilizată în declararea cursorului.

În afara atributului %NOTFOUND, în cazul cursoarelor explicite puteţi utiliza %ISOPEN, %FOUND, %ROWCOUNT. Vă lăsăm dvs. plăcerea de a descoperi rolul fiecăruia (tip: afişaţi ROWCOUNT în interiorul buclei).

Un exemplu în acest sens (care afişează lista studenţilor bursieri) este următorul:


 <nowiki>
DECLARE
   CURSOR lista_studenti_bursieri  IS
       SELECT nume, prenume FROM studenti WHERE bursa IS NOT NULL;
   v_nume studenti.nume%type;       
   v_prenume studenti.prenume%type;
BEGIN
    OPEN lista_studenti_bursieri;
    LOOP
        FETCH lista_studenti_bursieri INTO v_nume, v_prenume;
        EXIT WHEN lista_studenti_bursieri%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_nume||' '|| v_prenume);
    END LOOP;
    CLOSE lista_studenti_bursieri;  

<p>Evident că lista studenţilor bursieri putea fi afişată cu un simplu SELECT; daca doriti sa folositi datele in interiorul scriptului atunci trebuie sa folositi, totusi, un cursor. </p>

<p>Atunci când puteţi să evitaţi cursoarele explicite faceţi acest lucru. De exemplu, nu este nevoie să utilizaţi un cursor dacă doriţi să preluaţi fiecare linie dintr-un tabel (studenti) şi apoi să introduceţi anumite informaţii în alt tabel. Următorul cod populează o tabelă denumită indivizi cu toate persoanele existente în facultate fără a utiliza cursoare sau variabile.</p>

<pre><code class="language-sql">DROP TABLE indivizi;
CREATE TABLE indivizi(nume Varchar2(10), prenume varchar2(10));
BEGIN
   INSERT INTO indivizi SELECT upper(nume), prenume FROM studenti;
   INSERT INTO Indivizi SELECT upper(nume), prenume FROM profesori;

<p>Dacă selectul pe care l-am utilizat pentru a defini cursorul returnează foarte multe coloane, este anevoios să construim variabile pentru fiecare câmp ca apoi să le procesăm. În aceste cazuri se poate utiliza o variabilă în care se va încărca o întreagă linie. Variabila trebuie să fie declarată având ca tip nume_cursor%ROWTYPE şi pentru a accesa un anumit câmp returnat în această variabilă de va utiliza ".câmp". De exemplu, deşi în următorul cursor conţine toate informaţiile din tabela studenţi, putem să preluăm rând cu rând şi să afişăm doar numele studentului şi data sa de naştere:</p>

<pre><code class="language-sql">DECLARE
   CURSOR lista_studenti  IS
       SELECT * FROM studenti;
   v_std_linie lista_studenti%ROWTYPE;       
BEGIN
    OPEN lista_studenti;
    LOOP
        FETCH lista_studenti INTO v_std_linie;
        EXIT WHEN lista_studenti%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_std_linie.nume||' '|| v_std_linie.data_nastere);
    END LOOP;
    CLOSE lista_studenti;  

<p>Cursoarele explicite sunt foarte uşor de utilizat în bucle de tip FOR. Acestea vor deschide automat cursorul şi la fiecare iteraţie vor sări la următoarea linie şi vor face şi operaţia de FETCH într-o variabilă ce apare în comanda FOR. Câmpurile din această linie pot fi utilizate în aceeaşi manieră. Iată un exemplu (codul anterior rescris cu FOR):</p>

<pre><code class="language-sql">DECLARE
   CURSOR lista_studenti  IS
       SELECT * FROM studenti;
BEGIN
    FOR v_std_linie IN lista_studenti LOOP     
        DBMS_OUTPUT.PUT_LINE(v_std_linie.nume||' '|| v_std_linie.data_nastere);
    END LOOP;  

<p>Observaţi că: Nu mai avem nici una dintre operaţiile OPEN, FETCH, CLOSE. Nu am declarat (în zona de declaraţii) variabila %ROWTYPE v_std_linie ci aceasta este utilizată direct din structura FOR (declarare implicită). Nu a fost nevoie să scriem o instrucţiune de tip EXIT din buclă, ieşirea se face automat după ce au fost procesate toate rândurile.</p>

<p>Se poate chiar şi mai mult de atât: puteţi să nu declaraţi deloc cursorul ci să treceţi direct comanda de tip SELECT în FOR. Aceasta va fi pusă totuşi între paranteze rotunde:</p>

<pre><code class="language-sql">BEGIN
    FOR v_std_linie IN  (SELECT * FROM studenti) LOOP     
        DBMS_OUTPUT.PUT_LINE(v_std_linie.nume||' '|| v_std_linie.data_nastere);
    END LOOP;  

<p>Un cursor explicit poate fi declarat utilizând parametri (de exemplu din cauză ca am dori ca să deschidem cursorul după ce am calculat o anumită valoare şi această valoare să fie utilizată de către comanda select). Pentru aceasta vom utiliza un Cursor explicit cu parametru. Diferenţa este că după numele cursorului vor fi trecuţi între paranteze rotunde parametri şi tipul lor despărţiţi prin caracterul virgulă, aceşti parametri vor fi utilizaţi efectiv în comanda SELECT iar la deschiderea cursorului se vor da tot între paranteze rotunde valorile ce vor fi asociate fiecărui parametru (în ordinea în care aceştia apar). Iată un exemplu care afişează studenţii cu o bursă mai mare de 300 şăi care sunt în anul 2:</p>

<pre><code class="language-sql">DECLARE
   CURSOR lista_studenti_bursieri (p_bursa studenti.bursa%type, p_an studenti.an%type) IS
       SELECT nume, prenume FROM studenti WHERE bursa > p_bursa AND an > p_an;
   v_std_linie lista_studenti_bursieri%ROWTYPE;       
BEGIN
    OPEN lista_studenti_bursieri (300,2); -- aceste valori pot fi calculate de codul PLSQL
    LOOP
        FETCH lista_studenti_bursieri INTO v_std_linie;
        EXIT WHEN lista_studenti_bursieri%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_std_linie.nume||' '|| v_std_linie.prenume);
    END LOOP;
    CLOSE lista_studenti_bursieri;  

<h2> Declararea cursoarelor explicite cu clauza FOR UPDATE </h2>

<p>Dacă în timpul procesării cursorului dorim să modificăm o linie (sau chiar să o ştergem), după declararea cursorului se vor adăuga cuvintele "FOR UPDATE". Acest lucru va bloca accesul altor utilizatori ce doresc să scrie în tabela (sau tabelele) selectată de cursor dar va permite totuşi citirea acestor informaţii. După cuvintele cheie FOR UPDATE poate fi specificat un anumit câmp ce va poate fi modificat prin adăugarea cuvnântului cheie OF urmat de numele coloanei ce va ar putea fi modificată (în acest caz doar acea coloană va fi blocată).</p>

<p>În cazul în care se doreşte modificarea prin intermediul unui cursor a bazei de date şi altcineva deja are un cursor pentru modificare deschis pe aceeaşi tabelă, se poate specifica (în definiţia cursorului) un număr de secunde ce vor fi aşteptate după care se va reîncerca deschiderea cursorului. Dacă şi a doua oară eşuează, va fi returnată o eroare. Pentru a specifica numărul de secunde se adaugă la sfârşit cuvântul cheie WAIT urmat de numărul de secunde ce poate fi aşteptat. În cazul în care nu se doreşte aşteptarea, acest lucru va fi specificat prin prezenţa cuvântului cheie NOWAIT (în loc de "WAIT n").</p>

<p>Pentru a afecta rândul curent, după comanda ce indică modifcarea coloanei (sau ştergerea întregului rând) se vor adăuga cuvintele cheie "WHERE CURRENT OF" urmate de numele cursorului în care se face updateul.</p>

<p>Iată, în continuare, un script pe care toţi studenţii care au avut vreodată "probleme" la vreo materie şi-ar dori să îl execute pe serverul în care le sunt reţinute notele:</p>

<pre><code class="language-sql">DECLARE 
   CURSOR update_note IS
      SELECT * FROM note FOR UPDATE OF valoare NOWAIT;
BEGIN
   FOR v_linie IN update_note LOOP
       IF (v_linie.valoare < 5) 
            THEN 
                 UPDATE note SET valoare=5 WHERE CURRENT OF update_note;
       END IF;
   END LOOP;

<p>Observaţie: când facem updateul, acesta se realizează în tabela note şi nu în cursorul update_note.</p>


<p><!--</p>
<h6> Tema (2pt) </h6>
<p>Pentru tabelul a caror date le-ati expus in aplicatia facuta la tema precedenta, creati o interfata grafica care pentru fiecare dintre campurile afisate (macar 3) sa aiba cate doua butoane ce vor permite rearanjarea datelor asc/desc dupa acel camp. Interfata va permite si filtrarea datelor dupa un anumit criteriu. </p>

<p>Nota: Desi probabil pe unii v-ar tenta sa preluati toate informatiile din BD si sa le sortati / filtrati din PHP (ceea ce trebuie sa recunoastem ca ar fi mai eficient in momentul in care oricum aveti toate datele preluate in PHP), corect ar fi sa reinterogati baza de date - ganditi-va la baze de date care au miliarde de inregistrari si din care doresc sa iau doar 1% din date.</p>

<p>Intrebare: cum ati indexa baza de date pentru ca raspunsul de la BD sa fie cat mai rapid (testati cu si fara index). </p>





<h6> Exercitii </h6>

<p>1. (4pt) Construiti un bloc anonim care sa populeze un tabel care are aiba doua campuri A, B astfel: Valoarea campului A va contine toate numerele din intervalul 1..10000 care au proprietatea ca valoarea sumei cifrelor modulo 9 este egala cu valoarea unei constante declarate la inceputul scriptului (evident avand valoarea mai mica decat 9). Valoarea lui B va fi 0 sau 1 in functie de primalitatea numarului (1=prim, 0=neprim).</p>

<p>2. (2pt) Utilizand un cursor explicit deschis cu clauza FOR UPDATE, construiti un script care sa faca update campului B din tabelul de la punctul 1. In loc de prim acesta va indica daca numarul respectiv este sau nu o valoare din sirul lui Fibonacci. Scriptul va afisa numarul de valori updatate (adica ce s-a schimbat din 0 in 1 + ce s-a schimbat din 1 in 0).</p>

<p>3. (4pt) Construiti un bloc anonim care sa afiseze notele celui mai bun student din facultate care are macar trei note si materiile la care le-a luat. Daca sunt doi studenti care au aceeasi medie va fi afisat cel din an mai mare sau, in cazul in care sunt in acelasi an, vor fi afisate notele primului in ordine alfabetica. Nu aveti voie sa utilizati join sau produs cartezian in cadrul cursorului si nici functii de agregare pentru a calcula media (faceti-o matematic). Se vor afisa si numele si media studentului.</p>

<p>Pont: Pentru a va verifica ultima problema, un coleg de-al vostru (care a dorit sa ramana anonim) a construit urmatorul script (blocul anonim de la pt.3 ar trebui sa ofere un output similar - desi media sau numele studentului vor fi afisate o singura data):</p>

<pre><code class="language-sql">select T1.id, T1.nume, T1.prenume, T1.an, c.titlu_curs, n.valoare, T1."avg" from ( select * from (select  s.id, s.nume, s.prenume, s.an, 
avg(n.valoare) as "avg" from studenti s join note n on n.id_student=s.id group by s.id, s.nume, s.prenume, s.an, s.nume, s.prenume
having count(n.valoare) >= 3 order by avg(n.valoare) desc, s.an desc, s.nume asc, s.prenume asc ) where rownum = 1) T1 join note n on
n.id_student = T1.id join cursuri c on c.id = n.id_curs;



<p>Obligatoriu: Nu luati codul si nu oferiti codul colegilor ! Temele sunt individuale !</p>

<p><span style="color:red">Observatie:</span> Aceasta este tema numarul 2. Pentru a face upload creati un director in formatul Nume_Prenume_Grupa_2 si puneti in el trei fisiere: Nume_Prenume_Grupa_2_1.sql (ce va contine rezolvarea exercitiului 1), Nume_Prenume_Grupa_2_2.sql (ce va contine rezolvarea exercitiului 2) respectiv Nume_Prenume_Grupa_2_3.sql (ce va contine rezolvarea exercitiului 3). Arhivati cu ZIP directorul si asigurati-va ca arhiva are numele Nume_Prenume_Grupa_2.zip Dupa care folositi scriptul de upload pentru a o uploada. Scriptul de upload il gasiti aici: https://profs.info.uaic.ro/~vcosmin/pagini/upload_psgbd</p>

<p><span style="color:red">Observatie 2:</span> Daca ati gresit formatul (pentru ca nu ati stiut sa cititi mai sus sau in regulament), tema poate fi re-uploadata cu o penalizare de doua puncte. Pentru aceasta urmati pasii de mai sus dar adaugati sufixul "_v1", (sau "_v2" daca iar ati gresit, etc)... (e.g. Nume_Prenume_Grupa_2_v1.zip) fisierului zip obtinut in final.</p>
<p>--></p>
