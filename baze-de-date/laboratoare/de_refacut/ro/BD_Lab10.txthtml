<p>=Variabile de substituție SQL*Plus=</p>

<p>Variabilele de substituție au rolul de a suplini constante, condiții utilizate în clauza WHERE, nume de campuri utilizate în clauza ORDER BY, nume de tabele sau chiar întregi fraze SELECT.</p>

<p>Variabilele de substituție sunt precedate de simbolul <b>&</b> iar la execuția interogării SQLPlus va solicita de la utilizator valorile necesare.</p>

<p>Exemplu 1:</p>
<pre><code class="language-sql">SELECT *
    FROM studenti
    WHERE an=&an AND nume LIKE '&nume'

<p>Exemplu 2:</p>
<pre><code class="language-sql">SELECT nume, &camp_afisare
    FROM studenti
    WHERE &conditie2
    ORDER BY &camp_sortare;

<p>Executați interogările de mai sus de mai multe ori inserand diverse valori pentru variabilele de substituție. Verificați rezultatul.</p>

<p>Variabilele de substituție pot fi predefinite și instanțiate, caz în care la execuția interogării nu se mai solicită valoarea:</p>
<pre><code class="language-sql">DEFINE camp=prenume
SELECT nume, &camp
    FROM studenti
    ORDER BY &camp;

<p>Variabila este stocată pe parcursul sesiunii curente până la eliminarea ei cu comanda UNDEFINE sau până la închiderea sesiunii.</p>
<pre><code class="language-sql">UNDEFINE camp

<p>Comenzile DEFINE si UNDEFINE sunt specifice utilitarului SQL*Plus și nu limbajului SQL.</p>

<p>=Comenzi DML - Modificare date=</p>
<p>Până acum s-au utilizat în cadrul laboratoarelor doar comenzi de interogarea a datelor - adică fraza SELECT - care sunt parte tot din cadrul componentei DML (Data Manipulation Language) a limbajului SQL.</p>
<p>În această secțiune exemplificăm comenzile de modificare a datelor.</p>

<h2>Adăugarea înregistrărilor</h2>
<p>Inserarea de noi înregistrări în baza de date se realizează cu ajutorul comenzii INSERT care poate lua două forme:</p>
<p>{| border="1"</p>
<p>|<pre>INSERT INTO nume_tabel [ (lista_coloane) ]</p>
<p>      VALUES (lista_valori)</pre></p>
<p>| INSERT INTO cursuri VALUES(30, 'Inv. automata', 3, 1, 5);<br></p>
<p>INSERT INTO cursuri (ID_curs, titlu_curs) VALUES(31, 'NoSQL');</p>
<p>|-</p>
<p>|<pre>INSERT INTO nume_tabel [ (lista_coloane) ]</p>
<p>   fraza_select	</pre></p>
|
<p> INSERT INTO note </p>
<p> SELECT nr_matricol, 30, 10, SYSDATE</p>
<p>   FROM studenti</p>
<p>   WHERE an=3;</p>
<p>|}</p>

<h3>SECVENTE===</h3>
<p>De multe ori suntem puși în situația de a crea atribute sintetice care să joace rol de cheie, deci să ia valori unice în cadrul unei tabele. Secvențele sunt obiecte care ne ajută să generăm automat numere întregi unice în momentul inserării înregistrilor.</p>

<p>Sintaxa creării unei secvențe:</p>
<pre><code class="language-sql">CREATE SEQUENCE nume_secventa
  [INCREMENT BY n]               -- pasul
  [START WITH n1]                -- valoarea de start
  [MAXVALUE n_max | NOMAXVALUE]  -- valoarea de oprire
  [MINVALUE n_min | NOMINVALUE]  -- valoarea minima (listele pot fi siruri descrescatoare)
  [CYCLE | NOCYCLE]              -- daca se continua generarea cand se ajunge la min/max

<p>Comanda NEXTVAL generează următorul număr din șir iar CURRVAL obține valoarea curentă. NEXTVAL trebuie executată înainte ca lista să conțină breun număr.</p>

<p>CYCLE -> furnizati si optiunea NOCACHE</p>

<p>Exemplu:</p>
<pre><code class="language-sql">CREATE SEQUENCE s1
  INCREMENT BY 2
  START WITH 10
  MAXVALUE 15;

SELECT s1.NEXTVAL FROM DUAL; --executati in mod repetat comanda; cand ridica eroare?

<p>Pentru a elimina secventa se va executa comanda </p>
<pre><code class="language-sql">DROP SEQUENCE nume_secventa;

<h3>Exercitii===</h3>
<p>Cum poate fi utilizată o secvență la inserare?</p>
<p>Răspundeți creând o secvență care sa vă ajute sa inserați noi cursuri cu id unic, cu intrari consecutive crescătoare cu pasul 1. Inserati 3 cursuri noi cu id-ul generat de secventa.</p>

<h2>Actualizarea înregistrărilor</h2>
<p>{| border=1</p>
<p>|<pre>UPDATE nume_tabel [alias]</p>
<p>  SET nume_coloana1 = valoare1</p>
<p>     [, nume_coloana2 = valoare2...]</p>
<p>      [WHERE conditie]</pre>	</p>
<p>|UPDATE studenti </p>
<p>SET bursa=bursa*0.15</p>
<p>WHERE bursa<300;</p>
<p>|-</p>
<p>|<pre>UPDATE nume_tabel [alias]</p>
<p>  SET (nume_coloana1 [,nume_coloana2]...) = (subinterogare)</p>
<p>    [WHERE conditie]</pre></p>
|
<p>|}</p>
<h3>Exercitii===</h3>
<p>#Actualizati valoarea bursei pentru studentii care au măcar o notă de 10. Acestia vor primi ca bursa 500RON.</p>
<p>#Toti studentii primesc o bursa egala cu 100*media notelor lor. Efectuati modificarile necesare.</p>

<h2>Ștergerea înregistrărilor</h2>
<p>{| border=1</p>
<p>|<pre>DELETE FROM nume_tabel </p>
<p>  [WHERE conditie]</pre></p>
<p>|DELETE FROM note WHERE valoare < 5;</p>
<p>|}</p>

<h3>Exercitii===</h3>
<p>Stergeti toti studentii care nu au nici o nota.</p>

<p>=Comenzi DDL - creare/modificare structuri de date=</p>
<p>Aceste comenzi sunt menite a crea sau a șterge tabele (sau alte tipuri de obiecte), precum și a modifica structura tabelelor (obiectelor) existente. Comenzile necesare fac parte din componenta DDL (Data Definition Language) a limbajului SQL.</p>

<h2>CREATE TABLE AS</h2>
<p>Comenzile de creare a tabelelor au fost pe larg explicate la curs, cu diversele constrângeri care pot fi impuse asupra datelor la momentul creării. Aici tratăm doar comanda CREATE cu subinterogări.</p>

<pre><code class="language-sql">CREATE TABLE nume_tabel [(col1, col2,...)] [AS] fraza_select;

<p>Comanda este similară cu cea dedicată creării viewului, diferența fiind că la crearea unui tabel, acesta este umplut cu datele returnate de interogare.</p>
<h3>Exercitii===</h3>
<p>Executati comanda ROLLBACK. Creati apoi o tabelă care să stocheze numele, prenumele, bursa si mediile studentilor.</p>

<h2>ALTER TABLE</h2>
<p>Structura tabelelor create deja poate fi modificată, chiar dacă tabelul conține deja date. Modificările pot să vizeze adăugarea de noi coloane, ștergerea unor coloane existente, modificarea definiției unei coloane (tipul și constrângerile impuse), redenumirea unei coloane, redenumirea tabelului, adăugarea sau ștergerea de constângeri (chei candidat, chei primare, chei străine, constrângeri NOT NULL, CHECK).</p>

<p>Găsiți în continuare comenzile necesare: </p>
<p>{| border=1</p>
<p>|ALTER TABLE nume_tabel ADD (col1 definitie_col1 [,col2 definitie_col2....]) </p>
<p>||<pre>ALTER TABLE cursuri ADD (abreviere CHAR(2) NULL, </p>
<p>                 descriere VARCHAR(40) DEFAULT 'curs obligatoriu');</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_tabel DROP COLUMN col</p>
<p>||<pre>ALTER TABLE cursuri DROP COLUMN descriere;</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_tabel MODIFY (col1 definitie_col1 [,col2 definitie_col2....])</p>
<p>||<pre>ALTER TABLE profesori MODIFY (nume VARCHAR(20), </p>
<p>                            prenume VARCHAR(20));</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_tabel RENAME COLUMN col_veche TO col_noua</p>
<p>||<pre>ALTER TABLE note RENAME COLUMN valoare TO nota;</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_vechi_tabel RENAME TO nume_nou_tabel</p>
<p>||<pre>ALTER TABLE profesori RENAME TO cadre_didactice;</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_tabel ADD CONSTRAINT nume_constrangere definitie_constrangere;</p>
<p>||<pre>ALTER TABLE studenti ADD CONSTRAINT </p>
<p>     pk_studs PRIMARY KEY (nr_matricol);</pre></p>
<p><pre>ALTER TABLE note ADD CONSTRAINT </p>
<p>     fk_studs FOREIGN KEY (nr_matricol) </p>
<p>           REFERENCES studenti(nr_matricol) ON DELETE CASCADE;</pre></p>
<p>|-</p>
<p>|ALTER TABLE nume_tabel DROP CONSTRAINT nume_constrangere;</p>
<p>||<pre>ALTER TABLE note DROP CONSTRAINT fk_studs;</pre></p>
<p>|}</p>

<h3>Exercitii===</h3>
<p>Executati din nou scriptul de creare de aici: http://profs.info.uaic.ro/~vcosmin/BD/facultate.sql<br></p>
<p>#Adăugați constrângerile de tip cheie primară pentru tabelele Studenti, Profesori, Cursuri.</p>
<p>#Adăugați constrângerile referențiale pentru tabelele Note și Didactic. La ștergerea unui profesor din tabela Profesori, în tabela Didactic id-ul profesorului șters va deveni null. La stergerea unui curs din tabela Cursuri, in tabela Didactic va fi stearsă înregistrarea care referențiază cursul șters. Scrieți comenzi de ștergere înregistrări pentru tabelele referențiate și studiați comportamentul.</p>
<p>#Impuneți constrângerea ca un student să nu aibă mai mult de o notă la un curs.</p>
<p>#Impuneți constrângerea ca valoarea notei să fie cuprinsă între 1 și 10.</p>
<p><!-- alter table note add constraint my_check check(valoare between 1 and 10);--></p>

<p>=Tranzacții=</p>
<p>O tranzacție reprezintă un grup de comenzi de modificare de date (DML) care trebuie executate împreună, pentru a garanta consistența datelor. Eșuarea oricărei comenzi din cadrul unei tranzacții determină revenirea la starea inițială, dinaintea tranzacției.</p>

<p>O tranzacție începe de la prima comandă DML executată și se încheie la întâlnirea uneia dintre comenzile COMMIT și ROLLBACK, la întâlnirea unei comenzi DDL, la închiderea sesiunii sau la o eroare a sistemului. </p>

<p>Comanda ROLLBACK încheie tranzacția readucând baza de date la starea de dinaintea începerii tranzacției. O cădere a sistemului rezultă tot într-o comandă de tip ROLLBACK, adică revenirea la starea de dinaintea începerii tranzacției; este modalitatea prin care este protejată integritatea datelor. Restul situațiilor enumerate mai sus care determină încheierea unei tranzacții, fac ca modificările efectate asupra datelor să fie permanente, fără posibilitatea revenirii la o stare anterioară.</p>

<p>Imediat ce o tranzacție s-a încheiat, prima comandă DML lansată marchează nceputul uneia noi.</p>

<p>În cadrul acestui laborator ați executat comanda ROLLBACK înainte de a experimenta cu comanda CREATE TABLE, adică înainte de prima comandă de tip DDL lansată. Rezultatul a fost revenirea bazei de date la starea existentă la începutul sesiunii de lucru. Dacă nu ar fi fost lansată comanda ROLLBACK, modificările efectuate asupra datelor ar fi devenit permanente în momentul executării comenzii DDL (așa cum s-a specificat mai sus, orice comandă DDL încheie tranzacția marcând modificările ca fiind permanente).</p>

<p>Pe parcursul unei tranzacții pot fi adăugați niște marcatori/indicatori cu ajutorul cărora să putem reveni la stări intermediare. Adăugarea unui indicator se realizează cu ajutorul comenzii <pre>SAVEPOINT nume_indicator</pre> iar revenirea la starea bazei de date din acel moment se realizează cu ajutorul comenzii <pre>ROLLBACK TO SAVEPOINT nume_indicator</pre>.</p>

<p>Orice comandă DDL este considerată a forma o tranzacție.</p>


<h3>Exerciții</h3>
<p># Asigurati-va că începeți o nouă tranzacție.</p>
<p># Ștergeți toate înregistrările din tabela Profesori.</p>
<p># Inserați un profesor.</p>
<p># Marcați starea curentă ca 's1'.</p>
<p># Schimbați numele profesorului inserat.</p>
<p># Vizualizați datele.</p>
<p># Reveniți la starea s1.</p>
<p># Vizualizați datele.</p>
<p># Reveniția la starea de dinaintea ștergerii.</p>
