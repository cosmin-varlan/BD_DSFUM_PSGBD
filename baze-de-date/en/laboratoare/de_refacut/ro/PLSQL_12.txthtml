<p>Să se realizeze o aplicație WEB (neapărat) care să permită construirea și evaluarea unor teste grilă. Aplicația va fi realizată în doi pași:</p>

<p>= A. Primul pas = </p>

<p>(livrabil în laboratorul 12, valorând 5 puncte, prezentabil în timpul orelor de laborator via un protocol de comunicare agreat de profesor):  </p>

<p>Să se construiască în PLSQL:</p>

<p>O funcție "urmatoarea_intrebare" ce primeste doi parametri:</p>
<ul>
<li> parametrul <i>email</i> reprezintă adresa de email a unui utilizator care există în sistem (nu este nevoie să verificați, se va verifica în altă parte)</li>
<li> parametrul <i>raspuns</i> (ce poate fi și null). Dacă acest parametru nu este nul, el va fi conține un ID a unei întrebări din testul generat pentru utilizatorul identificat de parametrul email împreună cu ID-urile răspunsurilor pe care acesta le-a considerat corecte pentru acea întrebare.</li>
</ul>


<p>Funcția va returna fie următoarea întrebare la care utilizatorul nu a răspuns încă, fie punctajul final în cazul în care s-a răspuns la toate întrebările. Pentru aceasta va face următorii pași:</p>

<ul>
<li> Caută să vadă dacă în baza de date există un test asociat utilizatorului primit având contul ca parametru. Dacă nu există atunci va crea un test (vezi secțiunea "Creare test"). </li>
<li> Dacă cel de-al doilea parametru este nenul, atunci el reprezintă răspunsul unei întrebări din test și este adăugat pentru întrebarea corespunzătoare pentru a fi utlizat la calculul punctajului final (vezi secțiunea "Calcul punctaj").</li>
<li> Așa cum s-a precizat și în secțiunea "creare test", întrebările au asociat un număr de ordine pentru testul ce a fost generat. Funcția, în continuare, va prelua următoarea întrebare la care încă nu s-a răspuns și va fi trimisă către utilizator (în cazul când funcția tocmai a generat testul, va întoarce prima întrebare).</li>
<li> Dacă răspunsul dat este pentru ultima întrebare, se va calcula și stoca în baza de date punctajul testului după regulile stipulate în secțiunea "calcul punctaj" și valoarea îi va fi afișată utilizatorului.</li>
</ul>


<p><b> Observație: </b> Dacă se apelează funcția având null ca și răspuns atunci nu se va adăuga nimic în baza de date. Apelul de mai multe ori a acestei funcții având valoarea răspunsului null va avea acelasi efect: întoarcerea aceleiași întrebări (următoarea din test la care încă nu s-a răspuns). Nu se va putea reveni la o întrebare răspunsă în trecut și nici nu se va putea sări peste o întrebare pentru a reveni ulterior la ea.</p>


<h3> Creare test </h3>
<p>Testul creat pentru un utilizator va fi format dintr-un număr de 10 întrebări de tip grilă din diverse domenii (sau subdomenii ale unui aceluiași domeniu). Cele 10 întrebări vor avea asociat un număr de ordine, astfel încât mereu se va putea găsi care este "următoarea întrebare" la care nu s-a răspuns, sau ultima întrebare la care s-a răspuns. </p>

<p>Pentru generarea unei singure întrebări se va proceda astfel:</p>
<ul>
<li> Se va alege în mod aleatoriu un domeniu (sau subdomeniu) din care utilizatorul nu a fost încă întrebat nici o întrebare. Din cauză că în fiecare domeniu există mai multe întrebări posibile, se va alege una dintre ele.</li>
<li> Pentru întrebarea aleasă la punctul anterior, într-o tabelă de răspunsuri vor exista mai multe răspunsuri posibile (de exemplu 10 răspunsuri). Se vor prelua 6 răspunsuri care sunt compatibile cu acea întrebare (vezi exemplu), dintre care cel puțin un răspuns va fi corect. Ordinea lor va fi randomizată. ID-urile celor 6 răspunsuri seletate pentru întrebare vor fi memorate într-o tabelă împreună cu ID-ul întrebării, un număr de ordine a apariției întrebării în test și un câmp reprezentând răspunsurile date de utilizator (inițial null). Evident, pentru a ști că întrebarea face parte din testul unui anumit utilizator trebuie să păstrați aici și adresa de email a utilizatorului pentru care a fost generată întrebarea + cele 6 răspunsuri.</li>
<li> Se repetă pașii anteriori de 10 ori, pentru fiecare dintre cele 10 domenii câte o dată.</li>
<li> Funcția va returna o întrebare chiar după crearea testului: aceasta este prima întrebare.</li>
</ul>


<p><b>Notă:</b> Tabelele de întrebări și răspunsuri le puteți obține utilizând acest script: https://docs.google.com/document/d/1Ps0-R_4NyDkMK04Jmk3bhZiy4bKg2LIjEq_G4Scojqk/edit?usp=sharing ( acest document poate fi editat de oricine, special pentru a va permite sa adaugati restul domeniilor sau întrebări la cele existente - puneti intrebari usoare ca sa stim cu totii raspunsurile :D; <span style="color:red">cine face această temă este obligat să adauge în document măcar o întrebare !</span>)</p>


<h3> Obținerea unei întrebări </h3>

<p>La apelul funcției cu parametri email + răspuns se va proceda astfel:</p>
<ul>
<li> Dacă răspuns este null: se verifică dacă utilizatorul are un test deja creat. Dacă există test pentru utilizator, se va returna următoarea întrebare (în ordinea dată la crearea testului). Dacă nu, se va crea testul și se va returna prima întrebare.</li>
<li> Dacă răspuns nu este nul, acesta va conține IDul întrebării la care s-a răspuns împreună cu IDurile răspunsurilor considerate corecte. Se va verifica dacă nu există răspuns pentru acea întrebare și dacă într-adevăr nu există, ID-urile răspunsurilor se vor stoca pentru o analiză ulterioră (când se va calcula punctajul total). După aceasta se caută întrebarea următoare. Dacă există o următoare întrebare, ea va fi returnată clientului. </li>
<li> Indiferent de valoarea parametrului răspuns, dacă nu există o următoare întrebare înseamnă că testul s-a terminat și va fi întors un alt tip de răspuns reprezentând punctajul obținut (vezi secțiunea "Calcul punctaj" pentru detalii).</li>
</ul>


<h3> Calcul punctaj </h3>

<p>Pentru fiecare întrebare din testul unui utilizator, se va confrunta câmpul de răspunsuri corecte cu cel de răspunsuri date de utilizator. Fiecare întrebare va valora 10 puncte ce vor fi distribuite uniform între răspunsurile corecte alese pentru acea întrebare (sa zicem X; unde X = 10/nr_raspunsuri_corecte). </p>
<p>Răspunsurile corecte vor aduce un punctaj pozitiv (+X) utilizatorului în timp ce cele incorecte vor scadea din </p>
<p>punctajul total pentru acea întrebare (-X). Nici o întrebare nu va fi punctată negativ (minim=0).</p>

<p>Suma acestor punctaje va reprezenta punctajul final.</p>

<p>De exemplu, să zicem că prima întrebare a avut 10 răspunsuri posibile: 3 corecte și 7 incorecte. La generare s-a ales 6 răspunsuri: random un răspuns corect și încă 5 (din cele 9 rămase). Din cele 5 alese în partea a doua s-a mai ales încă un răspuns corect. Așadar la utilizator au ajuns două răspunsuri corecte și 4 incorecte. Deoarece sunt 2 răspunsuri corecte și găsirea acestora trebuie să aducă cele 10 puncte utilizatorului, fiecare răspuns va valora câte 5 puncte. Dacă utilizatorul bifează doar cele două răspunsuri corecte, el va obține 5 + 5 = 10 puncte. Dacă va bifa pe cele două corecte dar și unul incorect, el va obține 5 + 5 - 5 = 5 puncte. Dacă bifează toate răspunsurile, el totuși nu va primi -10 puncte ci nu va primi nimic (0 puncte). Si acesta este punctajul pentru prima întrebare. Dacă la a doua întrebare au fost selectate din întâmplare 3 răspunsuri corecte, fiecare va valora +3.33 puncte și fiecare răspuns gresit bifat va valora -3.33 etc.</p>


<h3> Exemplu ===</h3>
<p>S-a autentificat (printr-o verificare a tabelei utilizatori), utilizatorul cu adresa de email "ion@info.uaic.ro". </p>
<p>Se apelează funcția urmatoarea_intrebare având ca parametru doar adresa de email. Din cauză că nu există un test</p>
<p>asociat acestui utilizator, se va purcede la crearea lui: Se alege pentru început domeniul geometrie și din cele </p>
<p>5 întrebări disponibile în acest domeniu, a fost aleasă întrebarea "Care din următoarele figuri geometrice au 4 laturi ?".</p>
<p>Răspunsurile posibile pentru această întrebare sunt: *pătrat, cerc, triunghi, pentagon, *romb, *dreptunghi, *patrulater, </p>
<p>hexagon, octogon, decagon, dodecagon. Sistemul trebuie să aleagă un răspuns corect și apoi încă 5 răspunsuri aleatoare.</p>
<p>Spre exemplu a fost ales răspunsul *patrat ca fiind corect (în baza de date există un marker care identifică răspunsul</p>
<p>corect, în exemplu le-am marcat cu *) împreună cu alte 5 raspunsuri: triunghi, *romb, hexagon, octogon și dodecagon.</p>

<p>Pentru că aceste valori să fie identificate, se vor utiliza ID-urile lor.</p>

<p>De exemplu, în tabela de teste va fi adăugat un rând conținând valorile:</p>
<p>'ion@info.uaic.ro', 1, 23, 153, 149, 219, 74, 45, 317, '74,149', null</p>

<p>Având semnificațiile:</p>
<ul>
<li> identificare utilizaotrului</li>
<li> numărul de ordine al întrebării</li>
<li> ID-ul întrebării</li>
<li> cele 6 IDuri ale răspunurilor alese (în ordinea în care vor fi date utilizatorului - dar neapărat o ordine randomizată)</li>
<li> IDurile răspunsurilor corecte (ca și CSV)</li>
<li> IDurile răsunsurilir date de utilizator, ca și CSV - inițial null pentru că nu a răspuns la întrebare</li>
</ul>


<p>Procesul va fi repetat până la adăugarea a 10 întrebări din domenii diferite în test. Atenție, dintr-un domeniu poate</p>
<p>fi aleasă doar o întrebare, deși pot exista mai multe întrebări (putea pica și altă întrebare de geometrie).</p>

<p>După crearea întregului test, se va selecta prima întrebare (cea care este dată ca exemplu) și va fi dată</p>
<p>utilizatorului într-un format preferat de voi. De exemplu, dacă ar fi să îi trimiteți un JSON cu întrebarea,</p>
<p>acesta ar arăta astfel (nu este neapărat să fie format json sau codificarea să fie exact aceasta): </p>
<pre><code class="language-sql">"id_intrebare":23, "intrebare":"Care din următoarele figuri geometrice au 4 laturi ?", 
"id_rasp_1":153, "raspuns_1":"dodecagon",
"id_rasp_2":149, "raspuns_2":"patrat",
"id_rasp_3":219, "raspuns_3":"octogon",
"id_rasp_4":74,  "raspuns_4":"romb",
"id_rasp_5":45,  "raspuns_5":"hexagon",
"id_rasp_6":317, "raspuns_6":"triunghi",

<p>Evident, în acest format de intrebare nu se vor trimite și ID-urile ce indică răspunsurile corecte - ele trebuie</p>
<p>să fie știute doar de către serverul de baze de date si vor fi utilizate în calculul punctajului. Răspunsul furnizat</p>
<p>ca și parametru la un nou apel al funcției urmatoarea_intrebare poate spre exemplu avea formatul "23:149,219,74".</p>

<p>Apelul ulterior al funcției având parametri ca prim parametru "ion@info.uaic.ro" poate avea ca răspuns aceeași</p>
<p>primă întrebare dacă nu s-a furnizat nici un răspuns sau a doua întrebare dacă cel de-al doilea parametru este</p>
<p>"23:149,219,74", caz în care se va verifica că 23 este o întrebare la care nu s-a răspuns, se va stoca răspunsul</p>
<p>în locul câmpului ce era null ma sus '149,219,74' și se va genera un JSON pentru întrebarea cu numărul de ordine 2</p>
<p>pentru a fi returnat către client.</p>

<p>Dacă acesta funcția nu găsește o întrebare următoare (pentru că nu mai sunt întrebări), se va calcula punctajul</p>
<p>ca fiind suma punctajului fiecărei întrebăi in parte. </p>

<p>Pentru că în final vor fi acordate 100 de puncte, fiecare dintre cele 10 întrebări existente în test va valora </p>
<p>câte 10 puncte. Fiecare răspuns corect va fi punctat identic. Din acest motiv, în exemplul nostru în care sunt</p>
<p>două răspunsuri corecte, fiecare va valora 5 puncte. De asemenea, fiecare răspuns incorect va trebui penalizat,</p>
<p>penalizare se face cu aceeași valoare (de 5 puncte în acest caz), dar fără a deveni negativ. Pentru răspunsul </p>
<p>dat de Ion ("23:149,219,74"), punctajele pentru fiecare răspuns vor fi așadar de +5, -5, +5. Punctele obținute</p>
<p>în urma răspunsului fiind de 5. </p>

<p>Se face suma dintre punctajele acordate la fiecare întrebare și funcția urmatoarea_intrebare va furniza în final</p>
<p>un json de tipul {"Total":95} (la celelalte întrebări s-a răspuns perfect).</p>


<p>= B. Pasul al doilea = </p>

<p>(livrabil în săptămâna 13, valorând 5 puncte, prezentabil în timpul orelor de laborator via un protocol de comunicare agreat de profesor): </p>

<p>Să se realizeze o aplicație web simplă, respectând paradigma REST, având două rute / puncte de intrare / entry points:</p>

<h5> API REST - (partea 1) </h5>
<ul>
<li> Aplicația client face un apel către un prim entry point din APIul REST având ca parametru (dat prin POST) o adresa de email.</li>
<li> Primul entry point din API-ul REST va primi ca parametru o adresa de email și va returna o valoare construită ca hash peste adresa de email și timpul curent al serverului. Aceste două valori (adresa de email și hashul vor fi stocate într-o bază de date pe server). Valoarea hashului returnat împreună cu adresa de email vor fi stocate la client în localStorage (vezi https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).</li>
</ul>


<h5> API REST - (partea 2) </h5>
<ul>
<li> Aplicația client va trimite către un al doilea entry point din API-ul REST o cerere conținând adresa de email și hashul (tot prin POST pentru că va modifica starea serverului).</li>
<li> Al doilea entry point va verifica dacă cele două informații recepționate există în baza de date și, dacă aceste există și se validează că utilizatorul are hashul corect, se va apela funcția de generare a unei întrebări (din PLSQL). Răspunsul dat de către această funcție va fi furnizat către client care va randa întrebarea și o va afișa în pagina web (sau punctajul total în cazul în care răspunsul, tot de tip JSON, oferă această informație).</li>
<li> Dacă există deja o întrebare afișătă și se dorește a se da răspunsul la aceasta, se va apela aceeași rută având ca parametri pe lângă adresa de email + hashul de mai sus și un șir de caractere reprezentând răspunsul la întrebare (poate fi json, csv, etc. - aveți grijă doar ca în final să ajungă într-un format cunoscut la funcția "urmatoarea_intrebare" creată anterior).</li>
<li> Acest punct de intrare poate returna fie următorea întrebare, fie punctajul total. Afisați-le în mod corespunzător în aplicația client.</li>
</ul>


<p>= Bonus = </p>

<p>(2 puncte) Afișați utilizatorului nu numai punctajul final ci și care erau răspunsurile corecte + ce a bifat el împreună cu punctajul obțiunt sau scăzut pentru fiecare răspuns în parte.</p>



<p><!--</p>
<p>Nota: pentru aceasta problema nu aveti nevoie de nicio cunostinta suplimentara. Deoarece timpul de invatare este 0, timpul de realizare a problemei este mai mare (si am pus si un punctaj mai mare).</p>

<h2> Exercitiu (15pt) </h2>

<p>Sa se realizeze o aplicatie de rezolvare a testelor grila (poate fi aplicatie web, java, chiar si CLI - dar nu doar script PLSQL).</p>

<p>Aplicatia se va conecta la un server Oracle care ofera doua functii: </p>

<h4> Prima functie (6pt) </h4>

<p>Va permite autentificarea utilizatorului: va primi ca parametri numele utilizatorului si un hash al parolei si va verifica daca utilizatorul este inregistrat in baza de date avand asociat acel hash. In cazul in care utilizatorul se poate autentifica, veti crea un nou hash (H2) ce va fi asociat testului ce ii va fi generat acelui utilizator (in PLSQL puteti folosi ora_hash(param)). Intr-o nouta tabela veti stoca usernameul, noul hash generat (H2) si un test generat.</p>

<p>Cum se genereaza testul:</p>
<p>Testul va avea un numar de 10 intrebari din 10 domenii diferite; cate o intrebare din fiecare domeniu. </p>

<p>AL n-lea domeniu, notat cu Dn va contine un numar de intrebari pentru acel domeniu. Fiecare intrebare existenta in sistem va dispune de un numar de diferit de raspunsuri dintre care macar unul corect. </p>

<p>Pentru a genera o intrebare, in prima faza se selecteaza unul din domeniile care nu a fost inca selectat. Se ia random o intrebare din acel domeniu si apoi pentru acea intrebare se vor adauga un numar de 5 raspunsuri: primul raspuns va fi obligatoriu unuul corect si apoi se vor alege la intamplare din celelalte raspunsuri unul sau mai multe raspunsuri corecte sau incorecte (in total inca 4), avand grija sa nu aveti raspunsuri duplicate (daca alegeti random se poate ca sa nimeriti de doua ori peste acelasi raspuns). Dupa ce s-au selectat raspunsurile acestea se vor amesteca. Se procedeaza identic pentru restul intrebarilor pana cand nu mai sunt domenii de selectat.</p>

<p>Puteti stoca sub orce forma doriti testul (nested tables sau siruri de caractere in format CSV, etc.). De recomandat este ca nu pastrati efectiv continutul intrebarii ci mai degraba un ID al acesteia (la fel pentru raspunsurile asociate). Spre exemplu, as putea tine minte un test intr-un CSV de forma:</p>

<p>D4:q2-a75,a22,a89,a12,a34#D2:q94-a41,a77,a78,a80,a79#..... unde prin D4 am indicat ca prima intrebare a testului este din domeniul 4, este intrebarea care are IDul 2 in tabela de intrebari si raspunsurile selectate pentru aceasta sunt cele cu IDurile 75,22,89,12,34 - deja au si o ordine (spre exemplu s-ar putea ca raspunsurile corecte sa fie cele cu IDurile 89 si 34.) </p>

<p>Nu uitati: usernameul, hashul generat (H2) impreuna cu testul (in ce format vreti voi) trebuie sa fie stocate intr-o tabela. </p>

<p>Aceasta functie returneaza fie hashul generat H2 (inapoi aplicatiei PHP), fie o valoare standard (de exemplu 0 sau null) daca utilizatorul nu se poate autentifica in sistem.</p>

<p>In cazul in care utilizatorul se poate autentifica si el are deja un test generat dintr-o autentificare anterioara, se va returna hashul deja existent (H2 ce a fost generat data trecuta).</p>

<h4> Functia a doua (9pt) </h4>

<p>Va avea doi parametri:</p>
<ul>
<li> hashul H2 (pe care PHP-ul il cunoaste din cauza ca a fost returnat cand a fost apelata functia precedenta) </li>
<li> raspunsul la o intrebare anterioara (de exemplu: D4:q2-a89,a34 - a raspuns bine la prima intrebare).</li>
</ul>


<p>Functia va intoarce o intrebare impreuna cu raspunsurile posibile (ce vor fi afisate in interfata aplicatiei voastre) astfel:  In baza hashului, aceasta a doua functie va permite preluarea urmatoarei intrebari din test la care utilizatorul nu a raspuns inca (de exemplu, as putea sa verific tabela cu raspunsuri pentru raspunsurile care au fost date la testul cu hashul primit ca parametru). Dupa gasirea intrebarii urmatoare, aceasta va fi formulata intr-un sir de caractere parsabil de aplicatia voastra si trimisa catre aceasta. </p>

<p>Atunci cand aceasta functie nu mai poate genera nicio intrebare (pentru ca s-a ajuns la finalul testului), va calcula scorul final si il va returna aplicatiei intr-un format parsabil de aceasta (de exemplu: "Scor:92") si in acelasi timp il va trece intr-o tabela cu rezultate finale unde sunt tinute minte numele utilizatorilor si scorul final. Aplicatia va afisa scorul final.</p>

<p>Pentru calcularea scorului procedati astfel: cele 100 de puncte disponibile vor fi alocate identic fiecarui domeniu: pentru intrebarea din domeniu 1 vor fi date 10 puncte, pentru intrebarea din domeniul D2 alte 10 puncte si asa mai departe. Numarul de puncte asociate unei intrebari se imparte la numarul de raspunsuri corecte selectate. In exemplul de mai sus s-au ales 2 raspunsuri corecte, deci fiecare valoareaza 5 puncte. Pentru fiecare raspuns corect se adauga 5 puncte, pentru fiecare raspuns gresit se scad 5 puncte. Se va avea in vedere ca nu se dau punctaje negative - de exemplu, daca la intrebare data ca exemplu s-ar fi raspuns "D4:q2-a75,a22,a89", 89 fiind singurul corect, atunci intrebarea va valora 0 puncte.</p>

<p>Observatie: codul PLSQL poate contine si alte functii, dar in final aplicatia PHP nu va apela decat cele doua functii descrise mai sus.</p>


<p>Tabelele de intrebari si raspunsuri le puteti obtine utilizand acest script: https://docs.google.com/document/d/1Ps0-R_4NyDkMK04Jmk3bhZiy4bKg2LIjEq_G4Scojqk/edit?usp=sharing (<span style="color:red"> acest document poate fi editat de oricine, special pentru a va permite sa adaugati restul domeniilor - puneti intrebari usoare ca sa stim cu totii raspunsurile :D</span>)</p>


<h6> Exemplu / studiu de caz</h6>

<p>Acesta este doar un exemplu (probabil neeficient). Puteti sa implementati si in alte feluri povestea.</p>

<p>Gigel se are parola (neinspirata) gigi care criptata cu sha-1 este "3277d1158b8e7b677d96e0f6f0005c30035a9f37". El apeleaza prima functie:</p>
<p>functie1('Gigel', '3277d1158b8e7b677d96e0f6f0005c30035a9f37') din aplicatia PHP. Functia il cauta in tabelul cu utilizatori si vede ca parola este</p>
<p>corecta pentru utilizatorul Gigel. Cauta apoi in tabelul in care pastreaza testele si vede ca Gigel nu apare in acest tabel. Din acest motiv i se</p>
<p>construieste un hash (H2): 29152212 si i genereaza un test:</p>

<p>D2:Q6-A50,A45,A53,A54,A47#D1:Q2-A15,A16,A18,A19,A17#.......</p>

<p>Numele sau, impreuna cu H2 si cu testul generat sunt scrise in baza de date intr-un tabel de "Teste". Functia returneaza valoarea lui H2: 29152212 catre aplicatia PHP.</p>

<p>Aplicatia PHP acum apeleaza functia a doua astfel:</p>
<p>functie2(29152212, ");</p>
<p>functie2 returneaza textul intrebarii Q6 impreuna cu raspunsurile in ordinea prestabilita din testul generat, intr-un format ce poate fi parsat de PHP:</p>
<p>'Q6:Care din urmatoarele sunt numere pare ?*50:13*45:2*53:7*54:9*47:6'. Textul este despartit dupa caracterul * (despre care programatorul s-a asigurat ca</p>
<p>nu are cum sa apara in cadrul intrebarilor sau raspunsurilor) si afiseaza pentru gigel:</p>
<pre><code class="language-sql">Care din urmatoarele sunt numere pare ?
a) 13
b) 2
c) 7
d) 9
<p>Gigel este baiat istet dar neatent. Alege ca si numere pare pe cele de la pozitiile a,b si e. La apasarea butonului submit raspunsurile sunt trimise catre PHP</p>
<p>care apleaza functia 2 din nou, de aceasta data completand al doilea parametru:</p>
<p>functie2(29152212,'Q6-A50,A45,A47'). Apelul acesta va duce la completarea in baza de date cu raspunsuri a raspunsului lui Gigel: Q6-A50,A45,A47 dupa care se</p>
<p>observa in tabelul cu raspunsuri, care sunt intrebarile din testul lui gigel la care acesta nu a raspuns inca: Q2 (cea din domeniul 1). Este trimis catre PHP</p>
<p>sirul: 'Q2:Care din urmatoarele figuri geometrice au mai mult de 4 colturi ?*15:Dreptunghi*16:Paralelogram*18:Dodecagon*19:Pentagon*17:Hexagon'. </p>

<p>Procesul continua pana cand gigel ajunge la ultima intrebare. Cand trimite catre baza de date raspunsul catre aceasta ultima intrebare, din cauza ca nu se mai</p>
<p>gasesc intrebari la care sa se raspunda, serverul de baze de date calculeaza suma punctelor: fiecare intrebare avea 10 puncte. Intrebarea 1 avea doua raspunsuri</p>
<p>corecte selectate (cele cu ID-urile 45 si 47). Din acest motiv fiecare raspuns valoreaza 5 puncte (10/2). Gigel a raspuns cu IDurile 50,45,47 deci a luat</p>
<p>-5, 5, 5 = in total 5 puncte pentru aceasta intrebare. Calculul continua pentru restul intrebarilor si in final se afla ca suma este de 87.333. Se rotunjeste </p>
<p>superior (pentru ca sa nu il suparam pe gigel) si de aceasta data functia 2 trimite catre aplicatia PHP stringul 'Punctaj: 88' nu inainte de a scrie acest punctaj</p>
<p>intr-o tabela cu "note finale".  Gigel este bucuros. A trecut cu brio testul grila propus de voi.</p>

<p>--></p>
