<h2> Expresii regulate </h2>

<p>Expresiile regulate reprezintă șabloane sub formǎ de șiruri de caractere ce definesc câte o mulțime de cuvinte. Sunt o modalitate eficientă de a găsi, înlocui sau valida şiruri de caractere ce au un format bine definit. De exemplu pot fi folosite pentru a parsa url-uri, adrese de email sau chiar script-uri de cod.</p>
<p>Aceste şabloane sunt independente de limbaj, singurul lucru diferit fiind structura funcțiilor în cadrul cărora le utilizăm.</p>
<p>Limbajul PL/SQL are de asemenea un set de funcții ce folosesc expresii regulate.</p>

<h3> Utilitatea expresiilor regulate </h3>

<p>Pentru a pune în evidențǎ un prim avantaj al folosirii expresiilor regulate vom considera urmǎtorul exemplu: construirea unei funcții ce primeşte ca parametru un email şi returneazǎ 'Email valid' dacǎ acesta este valid, respectiv 'Email invalid' altfel. </p>
<p>Pentru a simplifica exemplul vom considera cǎ un email valid îndeplineşte urmǎtoarele proprietǎți: conține exact un caracter '@', urmat de exact un caracter '.', iar cele douǎ caractere despart trei secvențe de text ce nu conțin spații.</p>

<p>Uitați o variantǎ de rezolvare fǎrǎ utilizarea expresiilor regulate:</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION isValidEmail(p_email varchar2)
RETURN varchar2 AS
v_position INTEGER;
v_substr_email varchar2(20);
BEGIN
   v_position := INSTR(p_email,' ');
   IF (v_position!=0)  
   THEN
      return 'Email invalid';
   END IF;

   v_position := INSTR(p_email,'@');
   IF (v_position=0 OR v_position=1)  
   THEN
      return 'Email invalid';
   END IF;
   
   v_substr_email := SUBSTR(p_email,v_position+1);
   v_position := INSTR(v_substr_email, '.');
   IF (v_position=0 OR v_position=1 OR v_position=LENGTH(v_substr_email)) 
   THEN
      return 'Email invalid';
   END IF;
   
   return 'Email valid';
END isValidEmail;


<p>Comparați codul de mai sus cu urmǎtoarea rezolvare:</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION isValidEmail(p_email varchar2)
RETURN varchar2 AS
v_position INTEGER;
v_substr_email varchar2(20);
BEGIN
   IF (REGEXP_LIKE(p_email,'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+'))
   THEN
      return 'Email valid';
   END IF;
   
   return 'Email invalid';
   
END isValidEmail;


<p>Putem observa cǎ s-a redus considerabil numǎrul liniilor de cod, dar rezolvarea este de neînțeles pentru cineva cui nu îi este familiarǎ această structurǎ ce reprezintǎ o expresie regulată: </p>
<p>   </p>
<pre><code class="language-sql">'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+'

<h3> Construirea unei expresii regulate </h3>

<p>Reamintim, dupǎ cum ați studiat şi la cursul de limbaje formale, regulile de bazǎ pentru formarea expresiilor regulate. Am menționat mai sus cǎ acestea definesc mulțimi de cuvinte. În continuare vom prezenta cum sunt asociate simbolurile speciale, numite şi metacaractere, dintr-o expresie regulată cu şirurile de caractere din cuvinte. </p>

<p>{| border="1" </p>
<p>|Metacaracter	</p>
<p>|Descriere</p>
<p>|Exemplu</p>
<p>|-</p>
<p>|  '.'</p>
<p>|Înlocuiește orice caracter (cu excepția sfârşitului de linie vom vedea mai jos).</p>
<p>Când se află între simbolurile '[ ]' se comportǎ ca un literal normal.</p>
<p>|Expresia regulatǎ 'a.b' poate defini cuvintele 'aab', abb', 'a!b', dar nu 'ab','abbb' etc, iar expresia '.' nu poate fi sirul vid ''</p>
<p>|-</p>
<p>|  '[ ]'</p>
<p>|Înlocuiește un singur caracter ce se află între paranteze. </p>
<p>|Expresia regulată '[abcd]' poate defini doar cuvintele 'a', 'b', 'c' și 'd'. Se observa in exemplul [].*[\] = ‘].*[\’ ca multe caractere speciale devin caractere normale cand sunt intre paranteze patrate. Iar in cazul '[]]', expresia nu va da eroare fiindca daca dupa caracterul '[' urmeaza imediat ']' nu se considera sfarsit de subexpresie si va fi un caracter simplu, deci expresia poate fi doar caracterul ']'</p>
<p>|-</p>
<p>|  '-'</p>
<p>|Folosit între paranteze pătrate poate defini un interval de literali dacǎ este folosit ca în exemplu.</p>
<p>Altfel se comportă ca un literal normal.</p>
<p>|Expresia regulată '[a-d]' poate defini doar cuvintele 'a', 'b', 'c' și 'd'.</p>
<p>'[-abc]' definește cuvintele '-', 'a', 'b' și 'c'.</p>
<p>'[%--]' defineste caracterele dintre '%' si '-', '[--@]' defineste caracterele dintre '-' si '@'.</p>
<p>|-</p>
<p>|  '^'</p>
<p>|Folosit între paranteze pătrate ca în exemplu, marchează orice caracter cu excepția celor ce îi urmeazǎ.</p>
<p>Dacă nu se află între paranteze pătrate, corespunde începutului unui rând. </p>
<p>|Expresia regulată '[^a-d^f-h]' poate defini orice caracter exceptând 'a', 'b', 'c', 'd', '^', 'f', 'g' și 'h'.</p>
<p>'^ab[cd]' înlocuieşte cuvintele 'abc' și 'abd' dacă acestea se află la începutul unui rând.</p>
<p>|-</p>
<p>|  '$'</p>
<p>|Înlocuiește sfârșitul unui rând.</p>
<p>|'[a-bc-d]$' poate defini doar cuvintele 'a', 'b', 'c' și 'd' aflate la finalul unui rând.</p>
<p>|-</p>
<p>|  '( )'</p>
<p>|Marchează o subexpresie pe care pot fi aplicate mai multe metacaractere, care în lipsa parantezelor privesc doar caracterul precedent.</p>
<p>Fǎrǎ alte metacaractere acestea pot fi omise, subexpresia formată fiind echivalentă cu expresia simplǎ. </p>
<p>|'(abcd)' definește cuvântul 'abcd'.</p>
<p>|-</p>
<p>|  '+'</p>
<p>|Înlocuiește una sau mai multe apariții a subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'(abc)+' defineşte cuvintele 'abc', 'abcabc', 'abcabcabc...'</p>
<p>'ab+a' defineşte cuvintele 'aba', 'abba', dar nu și 'aa' sau 'abaa'.</p>
<p>nu este caracter special cand este intre paranteze patrate sau la inceput de expresie</p>
<p>|-</p>
<ul>
<li>'</li>
</ul>


<p>|Înlocuiește zero sau mai multe apariții a subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'(abc)*a' defineşte cuvintele 'a', 'abca', 'abcabc...a'.</p>
<ul>
<li>a' defineşte cuvintele 'aa', 'aba', 'abba'.</li>
</ul>


<p>nu este caracter special cand este intre paranteze patrate sau la inceput de expresie</p>
<p>|-</p>
<p>|  '?'</p>
<p>|Înlocuiește zero sau o singură apariție a subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'(abc)?a' defineşte doar cuvintele 'a' și 'abca'.</p>
<p>'ab?a' defineşte doar cuvintele 'aa' și  'aba'.</p>
<p>|-</p>
<p>| '{m}'</p>
<p>|Înlocuiește exact m apariții ale subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'(abc){2}' defineşte doar cuvântul 'abcabc'.</p>
<p>|-</p>
<p>| '{m,}'</p>
<p>|Înlocuiește cel puțin m apariții ale subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'[a-z]{2,}' defineşte cuvintele 'aa', 'abc', 'abcd' etc. Nu defineşte 'a', 'b', 'c' etc.</p>
<p>|-</p>
<p>| '{m,n}'</p>
<p>|Înlocuiește cel puțin m și cel mult n apariții ale subexpresiei anterioare sau a caracterului precedent.</p>
<p>|'[a-z]{2,3}' defineşte cuvintele 'aa', 'abc', etc. Nu defineşte 'a' și nici 'abcd'.</p>
<p>|-</p>
<pre><code class="language-sql">|Are acelaşi comportament ca operatorul OR din PL/SQL.
<p>|-</p>
<p>|  '\'</p>
<p>|Transformă metacaracterele în literali.</p>
<p>|'\[abc\]' defineşte cuvântul '[abc]'.</p>
<p>|-</p>
<p>|  '\n'</p>
<p>|Repetă rezultatul de la a n-a (1<=n<=9) subexpresie pornind de la poziția curentǎ din expresia regulată spre stânga.</p>
<pre><code class="language-sql">|}

{| border="1" 
|Metacaracter	
|Descriere
|Exemplu
|-
|'[:class:]'
| Potriveste orice caracter care apartine clasei specificate. Clasele sunt:
 [:alpha:] - clasa caracterelor alfabetice
 [:digit:] - clasa caracterelor ce reprezinta cifre
 [:alnum:] - clasa [:alpha:] si [:digit:] impreuna
 [:lower:] - clasa literelor mici
 [:upper:] - clasa literelor mari
 [:print:] - clasa caracterelor printabile
 [:punct:] - clasa caracterelor de punctuatie
 [:space:] - clasa caracterelor whitespace
 [:xdigit:] - clasa caracterelor hexadecimale
 [:graph:] - clasele [:punct:] + [:upper:] + [:lower:] + [:digit:] 
 [:blank:] - clasa caracterelor de spatii ce sunt goale (ex: tab, spatiu)
 [:cntrl:] - clasa caracterelor de control
 [:oriceNume:] - o clasa definita de utilizator
|Expresia regulata '[a-zA-Z]' potriveste un caracter din alfabetul englez, dar nu si din alte alfabete, iar toate pot fi potrivite de '[[:alpha:]]'.
Expresia '[[:upper:]]+' potriveste sirul 'ABCD' dar nu sirul 'ABCDef'.
|-
|'[=un caracter=]'
|Potriveste toate caracterele din clasa de echivalenta a caracterului pus intre '[= =]'.
|Daca a, à si â apartin aceleasi clase de echivalenta, atunci [[=a=]b], [[=à=]b] si [[=â=]b] sunt echivalente cu [aàâb].
|-
|'[.caractere.]'
|Potriveste caracterele puse intre '[. .]', dar ca un singur caracter, util pentru a putea caractere din alte limbi ce sunt scrise ca 2 caractere.
|'[[.ch.]]' - expresia regulata potriveste doar caracterul 'ch', nu caracterul 'c' sau 'h'.
|}


Oracle are suport pentru mai multe metacaractere influentate de limbajul de programare Perl.

{| border="1" 
|Metacaracter	
|Descriere
|Exemplu
|-
|  '\d'
|Înlocuiește orice cifra.
|Expresia regulatǎ '^(\d{4})-\d{3}-\d{3}$' poate defini un numar de delefon 0745-051-231. '\d' echivalent cu [[:digit:]]
|-
|  '\D'
|Înlocuiește orice caracter care nu este cifra. 
|Expresia regulata '\D{2,}(\d)*' poate defini orice sir care incepe cu macar 2 caractere ce nu sunt cifre si continua apoi cu oricate cifre, cum ar fi'S.G?B&D(1234'.
 '\D' echivalent cu [^[:digit:]]
|-
|  '\w'
|Înlocuiește orice caracter alphanumeric sau caracterul '_'
| echivalent cu [[:alphanum:]_]
|-
|  '\W'
|Înlocuiește orice caracter care nu e alphanumeric sau caracterul '_'.
|echivalent cu [^[:alphanum:]_]
|-
|  '\s'
|Înlocuiește orice caracter whitespace.
| echivalent cu [[:space:]], expresia regulata '\(\w\s\w\s\)' se potriveste cu sirul '(a b )' 
|-
|  '\S'
|Înlocuiește orice caracter care nu e whitespace.
|echivalent cu [^[:space:]], expresia regulata '\(\w\S\w\S\)' se potriveste cu sirul '(abcd)' dar nu cu '(a b c d)'
|-
|  '\A'
|Înlocuiește inceputul stringului. Daca stringul are mai multe newline-uri, nu se potriveste cu celelalte inceputuri de linii, ci doar cu primul.
|'\AL' se potriveste doar cu primul 'L' din textul 'Line1\nLine2\n', chiar daca stringul este o singura linie sau exista mai multe linii.
|-
| '\Z'
|Înlocuiește sfarsitul unui string sau caracterul dinaintea unui newline care este ultimul caracter din string. Daca string-ul are mai multe newline-uri (sunt mai multe linii),
 se potriveste doar cu ultimul sfarsit de string sau newline. 
| '\s\Z' se potriveste doar cu ultimul spatiu din string-ul 'L i n e \n', dar '\s' s-ar potrivi cu oricare din spatii sau caracterul '\n' din acel string
|-
|  '\z'
|Înlocuiește sfarsitul unui string.
|'\s\z' se potriveste cu newline-ul de la finalul string-ului 'L i n e \n', comparativ cu '\s\Z' care ignora newline-ul de la finalul stringului.
|-
| '{m}?'
|Înlocuiește exact m apariții ale subexpresiei anterioare sau a caracterului precedent. Asemenea lui '{m}', dar nu este greedy,
 adica se opreste la prima varianta gasita si nu cauta cea mai lunga.
|Daca cautam un sir conform expresiei '(a|aa){2}?' in sirul 'aaaa', se va gasi'aa', in timp ce pentru expresia '(a|aa){2}' va gasi 'aaaa'.
|-
| '{m,}?'
|Înlocuiește cel puțin m apariții ale subexpresiei anterioare sau a caracterului precedent. Asemenea lui '{m,}',dar nu este greedy, 
adica se opreste la prima varianta gasita si nu cauta cea mai lunga.
|Daca cautam un sir conform expresiei 'a{2,}?' in sirul 'aaaaa', se va gasi'aa', in timp ce pentru expresia 'a{2,}' va gasi 'aaaaa'.
|-
| '{m,n}?'
|Înlocuiește cel puțin m și cel mult n apariții ale subexpresiei anterioare sau a caracterului precedent. Asemenea lui '{m,n}',dar nu este greedy, 
 adica se opreste la prima varianta gasita si nu cauta cea mai lunga.
|Daca cautam un sir conform expresiei 'a{2,5}?' in sirul 'aaaaa', se va gasi'aa', in timp ce pentru expresia 'a{2,5}' va gasi 'aaaaa'.
|-
| '*?' 
|Înlocuiește zero sau mai multe apariții a subexpresiei anterioare sau a caracterului precedent.Asemenea lui '*', dar nu este greedy,
 adica se opreste la prima varianta gasita si nu cauta cea mai lunga. Cand va putea, va inlocui mereu caracterul vid ''.
|Expresia regulata '\w*?x\w' se potriveste cu stringul 'abxc' in sirul 'abxcxd', in timp ce expresia '\w*x\w' se va potrivi sirului 'abxcxd'
|-
|  '+?'
|Înlocuiește zero sau mai multe apariții a subexpresiei anterioare sau a caracterului precedent.Asemenea lui '*', dar nu este greedy,
 adica se opreste la prima varianta gasita si nu cauta cea mai lunga.
|Expresia regulata '\w+?x\w' se potriveste cu stringul 'abxc' in sirul 'abxcxd', in timp ce expresia '\w+x\w' se va potrivi sirului 'abxcxd'
|-
|  '??'
|Înlocuiește zero sau o singură apariție a subexpresiei anterioare sau a caracterului precedent. Asemenea lui '?', dar nu este greedy,
 adica se opreste la prima varianta gasita si nu cauta cea mai lunga.
| Expresia regulata 'a??aa' face o potrivire sirului 'aa' in sirul 'aaaa', in timp ce regula 'a?aa' va face potrivire sirului 'aaa' in sirul 'aaaa'
|}

Pentru mai multe metacaractare pe care le puteți folosi vizitați https://docs.oracle.com/cd/B12037_01/appdev.101/b10795/adfns_re.htm#1006817

=== Expresii regulate în PL/SQL ===

În continuare vom exemplifica în secvențe de cod câteva moduri de utilizare a funcțiilor din PL/SQL ce se folosesc de expresii regulate. 

==== Funcția REGEXP_LIKE ====

  <nowiki>
REGEXP_LIKE(source_string, pattern [, match_parameter ])

<ul>
<li> source_string - textul peste care dorim să facem potrivirea</li>
<li> pattern - expresia regulată </li>
<li> match_parameter - poate avea valorile 'i' (case insensitive), 'c' (case sensitive), 'n' (permite metacaracterului '.' sǎ înlocuiascǎ sfârșitul de linie), 'm' (se iau în considerare sfârșiturile de linie din text), 'x' (caractere whitespace sunt ignorate. by default, nu sunt ignorate)</li>
</ul>


<p> daca parametrul match_parameter este completat cu 'ci', unde 'c' si 'i' sunt contradictorii dupa comportament, se va lua in considerare cel mai din dreapta, in cazul acesta 'i'.</p>
<p>Funcția returneazǎ TRUE dacă expresia regulatǎ se potrivește peste cuvântul dat și FALSE altfel.</p>
<p>Reluǎm primul exemplu din laborator, pentru a evidenția rolul parametrilor acceptați de funcția REGEXP_LIKE.</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION isValidEmail(p_email varchar2)
RETURN varchar2 AS
v_position INTEGER;
v_substr_email varchar2(20);
BEGIN
   IF (REGEXP_LIKE(p_email,'[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]+','i'))
   THEN
      return 'Email valid';
   END IF;
   
   return 'Email invalid';
   
END isValidEmail;

<p>Funcția REGEXP_LIKE se comportǎ asemǎnǎtor funcției LIKE, utilizând adițional expresii regulate, după cum se poate intui din nume ("regular expression like"). Observăm că am reușit să scurtăm și mai mult codul folosind parametrul 'i'. </p>

<h4> Funcția REGEXP_REPLACE </h4>

<pre><code class="language-sql">REGEXP_REPLACE(source_string, pattern [, replace_string [, position [, occurrence [, match_parameter ] ] ] )

<ul>
<li> source_string - textul peste care dorim să facem potrivirea</li>
<li> pattern - expresia regulată</li>
<li> replace_string - textul cu care se va face înlocuirea; acesta poate fi un text normal, dar poate conține și metacaracterul '\n' după cum vom vedea în exemplul de mai jos</li>
<li> position - poziția din text de unde începe căutarea potrivirilor</li>
<li> occurrence - când e setat pe 0 înlocuiește toate potrivirele, altfel dacǎ are valoarea n>0, înlocuiește a n-a potrivire</li>
<li> match_parameter - poate avea valorile 'i' (case insensitive), 'c' (case sensitive), 'n' (permite metacaracterului '.' sǎ înlocuiascǎ sfârșitul de linie), 'm' (se iau în considerare sfârșiturile de linie din text), 'x' (caractere whitespace sunt ignorate. by default, nu sunt ignorate)</li>
</ul>


<p> daca parametrul match_parameter este completat cu 'ci', unde 'c' si 'i' sunt contradictorii dupa comportament, se va lua in considerare cel mai din dreapta, in cazul acesta 'i'.</p>

<p>În exemplul următor avem o procedură care primeşte ca parametru un text şi îl afișeazǎ cu vocalele dublate.</p>

<pre><code class="language-sql">CREATE OR REPLACE PROCEDURE dubleaza_vocale(p_string varchar2) AS
BEGIN
  
  DBMS_OUTPUT.PUT_LINE(REGEXP_REPLACE(p_string, '([aeiou])' ,'\1\1',1,0,'i'));
   
END  dubleaza_vocale;

<p>Pe lângǎ comportamentul funcției REPLACE și avantajul definirii unui şablon cu ajutorul expresiilor regulate, funcția REGEXP_REPLACE are capacitatea de a folosi rezultatul subexpresiilor din șablon în textul cu care se face înlocuirea.</p>

<h4> Funcția REGEXP_INSTR </h4>

<pre><code class="language-sql">REGEXP_INSTR (source_string, pattern [, position [, occurrence[, return_option [, match_parameter ] ] ] ] )

<ul>
<li> source_string - textul peste care dorim să facem potrivirea</li>
<li> pattern - expresia regulată</li>
<li> position - poziția din text de unde începe căutarea potrivirilor</li>
<li> occurrence - o valoare pozitivă ce reprezintă numǎrul de ordine al potrivirii cǎutate</li>
<li> return_option - când este 0 funcția returneazǎ poziția primului caracter din potrivire, iar când este 1 returneazǎ poziția primului caracter de după potrivire</li>
<li> match_parameter - poate avea valorile 'i' (case insensitive), 'c' (case sensitive), 'n' (permite metacaracterului '.' sǎ înlocuiascǎ sfârșitul de linie), 'm' (se iau în considerare sfârșiturile de linie din text), 'x' (caractere whitespace sunt ignorate. by default, nu sunt ignorate)</li>
</ul>


<p> daca parametrul match_parameter este completat cu 'ci', unde 'c' si 'i' sunt contradictorii dupa comportament, se va lua in considerare cel mai din dreapta, in cazul acesta 'i'.</p>

<p>Mai jos vedem o funcție ce primește un text și un număr k și returneazǎ poziția pentru al k-lea cuvânt din text.</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION cauta_al_k_lea(p_string varchar2, p_k INTEGER) 
RETURN INTEGER AS
BEGIN
  
  return REGEXP_INSTR (p_string, '[^ ]+' ,1,p_k,0);
   
END cauta_al_k_lea;

<h4> Funcția REGEXP_SUBSTR </h4>

<pre><code class="language-sql">  REGEXP_SUBSTR(source_string, pattern [, position[, occurrence [, match_parameter ] ] ] )

<ul>
<li> source_string - textul peste care dorim să facem potrivirea</li>
<li> pattern - expresia regulată</li>
<li> position - poziția din text de unde începe căutarea potrivirilor</li>
<li> occurrence - o valoare pozitivă ce reprezintă numǎrul de ordine al potrivirii cǎutate</li>
<li> match_parameter - poate avea valorile 'i' (case insensitive), 'c' (case sensitive), 'n' (permite metacaracterului '.' sǎ înlocuiascǎ sfârșitul de linie), 'm' (se iau în considerare sfârșiturile de linie din text), 'x' (caractere whitespace sunt ignorate. by default, nu sunt ignorate)</li>
</ul>


<p> daca parametrul match_parameter este completat cu 'ci', unde 'c' si 'i' sunt contradictorii dupa comportament, se va lua in considerare cel mai din dreapta, in cazul acesta 'i'.</p>

<p>În urmǎtoarea secvențǎ de cod am schimbat funcția de mai sus pentru a returna în loc de poziție, chiar cuvântul în sine.</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION cauta_al_k_lea(p_string varchar2, p_k NUMBER) 
RETURN varchar2 AS
BEGIN
  
  return REGEXP_SUBSTR(p_string, '[^ ]+' ,1,p_k);
   
END cauta_al_k_lea;

<p>Interogarea urmatoare arata cum se poate folosi functia REGEXP_SUBSTR inauntrul ei, in locul parametrului source_string.</p>
<p>Functia din interior va returna string-uri precum '@gmail.', dar daca noi vrem doar 'gmail', folosim inca odata functia pentru a scapa de caracterele '@' si '.'. </p>

<pre><code class="language-sql">SELECT id, nume, prenume,  REGEXP_SUBSTR (REGEXP_SUBSTR (mail, '@[^@.]+.', 1, 1, 'c'), '[^@.]+', 1, 1, 'c') AS "mail service"
FROM clienti;
</nowiki

==== Funcția REGEXP_COUNT ====

  <nowiki>
  REGEXP_COUNT(source_string, pattern [, match_parameter ] )

<ul>
<li> source_string - textul peste care dorim să facem potrivirea</li>
<li> pattern - expresia regulată</li>
<li> match_parameter - poate avea valorile 'i' (case insensitive), 'c' (case sensitive), 'n' (permite metacaracterului '.' sǎ înlocuiascǎ sfârșitul de linie), 'm' (se iau în considerare sfârșiturile de linie din text), 'x' (caractere whitespace sunt ignorate. by default, nu sunt ignorate)</li>
</ul>


<p> daca parametrul match_parameter este completat cu 'ci', unde 'c' si 'i' sunt contradictorii dupa comportament, se va lua in considerare cel mai din dreapta, in cazul acesta 'i'.</p>

<p>In urmatoarea secventa de cod se observa cum e folosita aceasta functie pentru a numara de cate ori apare cuvantul 'tablou'.</p>
<p>Se observa ca pattern-ul este 'ta.?blou', adica potriveste cuvantul 'tablou' sau orice cuvant de genul dar in care se afla un caracter intra 'ta' si 'blou'.</p>
<p>Rezultatul va fi 4, dar de asemenea daca nu se punea 'n' in parametrul match_parameter, rezultatul ar fi fost 3, pentru ca exista in text cuvantul 'ta\nblou'.</p>

<pre><code class="language-sql">set serveroutput on;
DECLARE
v_text VARCHAR(1000);
BEGIN
v_text := 'Tablourile tabloul ta
blou tablou';
 DBMS_OUTPUT.PUT_LINE(REGEXP_COUNT(v_text, 'ta.?blou' ,1,'in'));

end;

<p>Autori: Ciubotaru Adina-Maria, Bǎdițǎ Alexandru-George, Alexandru Donica</p>
