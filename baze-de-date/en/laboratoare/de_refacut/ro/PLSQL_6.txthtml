<p>= Obiecte = </p>

<p>Linkuri utile:</p>

<ul>
<li> http://www.tutorialspoint.com/plsql/plsql_object_oriented.htm</li>
<li> https://docs.oracle.com/cd/B28359_01/appdev.111/b28371/adobjplsql.htm</li>
<li> https://docs.oracle.com/cd/B13789_01/appdev.101/b10807/10_objs.htm#i16312</li>
</ul>


<p>În majoritatea limbajelor de programare moderne programarea este orientată-obiect. Deşi scripturile care sunt necesare în cadrul bazelor de date sunt de obicei destul de simple şi fac lucruri specifice asupra unei baze de date, şi în cadrul PL/SQL este permis lucrul cu obiecte. </p>


<p>Câteva dintre conceptele pe care le cunoaşteţi de la OOP (C++ sau Java) sunt implementate şi aici. Puteţi să compuneţi tipuri, să derivaţi obiecte noi din altele deja existente, etc. Ca şi în programarea OOP, obiectele au o mulţime de proprietăţi (sau atribute) şi o mulţime de metode. Atributele sunt utilizate pentru a reprezenta starea obiectului în timp ce metodele sunt utilizate pentru a simula diverse comportamente ale obiectelor.</p>

<h2> Construirea unei clase in PL/SQL </h2>

<p>"Clasa" din care este făcut un obiect este de fapt un tip pe care îl puteţi declara după sintaxa:</p>

<pre><code class="language-sql">
În secţiunea dintre paranteze sunt declarate atributele obiectului şi tipurile lor împreună cu procedurile şi funcţiile membre. Un exemplu în acest sens (vom construi un tip student prin intermediul căruia vom putea "instanţia" studenţi) este următorul:

 <nowiki>
CREATE OR REPLACE TYPE student AS OBJECT
(nume varchar2(10),
 prenume varchar2(10),
 grupa varchar2(4),
 an number(1), 
 data_nastere date,
 member procedure afiseaza_foaie_matricola
);

<p>În cadrul declaraţiei unui obiect nu puteţi să utilizaţi %TYPE. Acest lucru nu este valid deoarece dacă cineva se hotărăşte să modifice tabela pe baza căreia obiectul a fost construit atunci şi obiectul ar avea de suferit (şi probabil şi alte subprograme ce folosesc acest obiect).</p>

<p>Împreună cu declararea unui obiect trebuie declarat şi un BODY pentru acel obiect. În acest body pot fi scrise implementările pentru metodele declarate în obiect (de exemplu pentru procedura afiseaza_foaia_matricola). </p>

<p>Pentru a crea secţiunea de body se va utiliza următoarea sintaxă:</p>


<pre><code class="language-sql">CREATE OR REPLACE TYPE BODY student AS
          .................

<p>Între antetul BODYului şi cuvântul END sunt scrise toate implementările metodelor declarate în obiect. Ca şi exemplu, pentru obiectul student de mai sus vom putea declara următorul body:</p>

<pre><code class="language-sql">CREATE OR REPLACE TYPE BODY student AS
   MEMBER PROCEDURE afiseaza_foaie_matricola IS
   BEGIN
       DBMS_OUTPUT.PUT_LINE('Aceasta procedura calculeaza si afiseaza foaia matricola');
   END afiseaza_foaie_matricola;
END;

<p>Putem să creem tabele în care să introducem ca şi coloană valori-instanţă ale tipului nou creat (student). De exemplu, dacă executăm comanda următoare vom crea un tabel de tip cheie-valoare în care ca şi cheie vom trece numărul matricol al studentului iar ca şi valoare vom introduce efectiv obiectul:</p>

<pre><code class="language-sql">CREATE TABLE studenti_oop (nr_matricol VARCHAR2(4), obiect STUDENT);
</code></pre>


<p>Un exemplu de declarare şi utilizare a unui obiect de tip student precum şi o comandă de inserare în tabela nou creată este dat în continuare:</p>

<pre><code class="language-sql">set serveroutput on;
DECLARE
   v_student1 STUDENT;
   v_student2 STUDENT;
BEGIN
   v_student1 := student('Popescu', 'Ionut', 'A2', 3, TO_DATE('11/04/1994', 'dd/mm/yyyy'));
   v_student2 := student('Vasilescu', 'George', 'A4', 3, TO_DATE('22/03/1995', 'dd/mm/yyyy'));
   v_student1.afiseaza_foaie_matricola();
   dbms_output.put_line(v_student1.nume);
   insert into studenti_oop values ('100', v_student1);
   insert into studenti_oop values ('101', v_student2);

<p>Acum puteti sa construiti o cerere de tip select care sa va returneze doar anumite campuri din obiectul stocat in baza de date in campul "obiect":</p>

<pre><code class="language-sql">SELECT TREAT(obiect AS student).nume FROM studenti_oop;
</code></pre>


<p>În cadrul obiectului puteţi să declaraţi şi funcţii (în mod asemănător cum a fost definită şi procedura dar cu diferenţele specifice funcţiilor). Antetul funcţiei din body va fi trecut în declaraţia obiectului. Nu uitaţi de cuvântul cheie "Member".</p>

<p>După cum se poate observa în exemplul pe care l-am dat, un obiect are un constructor (care este apelat prin numele tipului obiectului) care preia ca parametri valorile atributelor din acel obiect (în ordinea declarării lor) şi le atribuie obiectului. Dacă doriţi să aveţi un constructor propriu (şi nu cel implicit), iată cum se face acest lucru în cazul exemplului nostru:</p>

<p>În cadrul declaraţiei obiectului adăugaţi ca şi metodă constructorul:</p>


<pre><code class="language-sql">  CONSTRUCTOR FUNCTION student(nume varchar2, prenume varchar2)
    RETURN SELF AS RESULT
</code></pre>


<p>Apoi, în cadrul body-ului, specificaţi ce doriţi să faceţi în această nouă metodă-constructor:</p>

<pre><code class="language-sql">CONSTRUCTOR FUNCTION student(nume varchar2, prenume varchar2)
    RETURN SELF AS RESULT
  AS
  BEGIN
    SELF.nume := nume;
    SELF.prenume := prenume;
    SELF.data_nastere := sysdate;
    SELF.an := 1;
    SELF.grupa := 'A1';
    RETURN;

<p>Declaraţi o nouă variabilă de tipul student şi instanţiaţi-o folosind noul constructor ce tocmai a fost definit.</p>

<p>Înafara constructorului, o altă metodă "mai specială" este cea care permite compararea a două de acelaşi tip. Această funcţie este necesară pentru că, în mod normal, SGBDul nu ştie care dintre cele două variabile pe care le-am declarat mai sus (v_student1 şi v_student2) este mai mare. În cazul în care am dori să sortăm tabela studenti_oop (declarată mai sus) după coloana obiect, ce ordine ar fi adoptată (cum ar fi comparate două elemente ale acestei coloane? după nume, după prenume sau poate după vârsta studentului ?).</p>

<h2> Sortarea şi comparararea </h2>

<p>În continuare vă invităm să construiţi în cadrul obiectului student a unei funcţii (nu denumirea varsta_in_zile) ce returnează vârsta în zile a studentului (scădeţi din sysdate valoarea data_nastere din obiect). Vom folosi această funcţie pentru a compara doi studenţi.</p>

<p>Există două metode de a compara două obiecte: Printr-o metodă MAP sau printr-o metodă Order. Metoda de tip MAP va returna o valoare (spre exemplu de tip number). Dacă primul obiect returnează un număr mai mic decat cel de-al doilea obiect atunci el este considerat mai mic.  </p>

<p>Adăugând cuvântul "MAP" în faţa funcţiei varsta_in_zile (pe care aţi creat-o puţin mai înainte), veţi putea compara doua obiecte de tip student în funcţie de numărul de zile de când s-au născut.</p>

<p>Adăugaţi în blocul anonim următoarea secţiune de cod:</p>

<pre><code class="language-sql">   if (v_student1 < v_student2) 
      THEN DBMS_OUTPUT.PUT_LINE('Studentul '|| v_student1.nume || ' este mai tanar.');
      ELSE DBMS_OUTPUT.PUT_LINE('Studentul '|| v_student2.nume || ' este mai tanar.');
   END IF;
</code></pre>


<p>În cele mai multe limbaje de programare funcţia de comparare nu este bazată pe reprezentarea obiectului ca şi o valoare ce ar putea fi comparată cu cea obţinută din reprezentarea similară a unui alt obiect ci mai degrabă prin întoarcerea uneia dintre valorile -1, 0, 1 (în funcţie dacă obiectul curent SELF în PLSQL sau this în Java spre exemplu este -1: mai mic, 0: egal, 1: mai mare decât obiectul dat ca parametru). </p>

<p>Diferenţa dintre cele două funcţii: MAP şi ORDER este că în timp ce funcţia de tip MAP nu are nevoie de nici un parametru pentru că întoarce reprezentarea obiectului curent ca un tip de dată comparabilă, funcţia de tip ORDER are obligatoriu ca parametru un obiect de acelaşi tip cu obiectul cu care se face comparaţia. Nu se pot folosi ambele metode în acelaşi timp, pentru comparaţia ce va fi făcută cu metoda ORDER, codul dat mai sus pentru MAP este în continuare corect.  Încercaţi să rescrieţi funcţia MAP astfel încât să fie de top ORDER (de fapt când se compară (v_student1 < v_student2) puteţi să vă închipuiţi că se apelează ceva de genul "v_student1.comparaCu(v_student2)" şi de fapt funcţia comparaCu este funcţia ce trebuie declarata cu ORDER).</p>

<h2> Moştenirea în PLSQL </h2>

<p>În PLSQL, la fel ca şi în alte limbaje orientate obiect, se pot crea obiecte plecând de la obiectele existente. Pentru a putea crea un obiect-copil, clasa parinte (superclasă) trebuie să fie declarată ca NOT FINAL (valoarea predefinită este FINAL). Refaceţi tipul student adăugând cuvintele NOT FINAL la final. Pentru a permite suprascrierea unei metode din cadrul obiectului, în faţa declaraţiei sale trebuie să fie scrise cuvintele NOT FINAL.</p>

<p>În exemplul nostru am putea construi declaraţia studentului în felul următor:</p>

<pre><code class="language-sql">CREATE OR REPLACE TYPE student AS OBJECT
(nume varchar2(10),
 prenume varchar2(10),
 grupa varchar2(4),
 an number(1), 
 data_nastere date,
 NOT FINAL member procedure afiseaza_foaie_matricola,
 map member FUNCTION varsta_in_zile RETURN NUMBER, 
 CONSTRUCTOR FUNCTION student(nume varchar2, prenume varchar2)
    RETURN SELF AS RESULT
) NOT FINAL;

<p>În acest caz, se poate crea un nou tip (clasă) ca şi subclasă pentru student şi, mai mult, în această nouă subclasă putem să suprascriem procedura afiseaza_foaia_matricola. </p>

<p>Iată în continuare codul care creează o subclasă a clasei student care are în plus o proprietate "bursa" şi care suprascrie metoda de afişare a foii matricole. Totodată este dat şi blocul anonimŞ care ar putea fi utilizat pentru a declara şi utiliza acest nou tip de obiect.</p>


<pre><code class="language-sql">drop type student_bazat;
CREATE OR REPLACE TYPE student_bazat UNDER student
(    
   bursa NUMBER(6,2),
   OVERRIDING member procedure afiseaza_foaie_matricola
)
/


CREATE OR REPLACE TYPE BODY student_bazat AS
    OVERRIDING MEMBER PROCEDURE afiseaza_foaie_matricola IS
    BEGIN
       dbms_output.put_line('bursier');
    END afiseaza_foaie_matricola;
END;
/

DECLARE
   v_student_bazat student_bazat;
BEGIN
    v_student_bazat := student_bazat('Mihalcea', 'Mircea', 'A1', 2, TO_DATE('18/09/1996', 'dd/mm/yyyy'), 1000);
    dbms_output.put_line(v_student_bazat.nume);
    v_student_bazat.afiseaza_foaie_matricola();

<p>Construiţi două instanţe ale studentului bazat şi comparaţi-le. Se păstrează metoda de comparare pe care aţi utilizat-o în compararea obiectelor de tip student declarat iniţial ?</p>

<p>Executaţi comanda:</p>

<pre><code class="language-sql">
Pentru a crea o clasă abstractă utilizaţi NOT INSTANTIABLE după declaraţia clasei (înainte de NOT FINAL). Are rost să folosiţi NOT INSTANTIABLE fără a fi urmată de NOT FINAL  ?

Executaţi codul:


 <nowiki>
DECLARE
  s student;
BEGIN
  SELECT obiect INTO s FROM studenti_oop WHERE nr_matricol='100';
  dbms_output.put_line(s.nume);



<p><!--</p>
<p>=Exercitii =</p>
<p>Exercitiul 1 (10pt)</p>

<ul>
<li> (2pt) Construiti la alegere o clasa. Clasa trebuie sa aiba macar doua metode si macar un constructor aditional (inafara celui implicit).</li>
<li>  (2pt) Pentru clasa construita la punctul precedent oferiti o metoda de comparare a doua obiecte (MAP sau ORDER), inserati o serie de obiecte intr-o tabela si incercati sa le ordonati dupa coloana in care este introdus obiectul pentru a demonstra ca obiectele pot fi intr-adevar comparate unul cu celalalt.</li>
<li> (2pt) Construiti o subclasa care sa aiba ca si clasa de baza pe cea construita la primul punct. Suprascrieti macar o metoda din cele existente in clasa de la punctul 1. Dati si un exemplu de metoda ce nu poate suprascrisa.</li>
<li> (2pt) Stiind ca supraincarcarea (overloading) este facuta doar prin declararea unei functii cu acelasi nume dar cu parametri diferiti, exemplificati acest procedeu pentru una din clasele pe care le-ati definit (fie cea de la punctul 1, fie cea de la punctul 3).</li>
<li> (2pt) Construiti un cod PLSQL si unul Java prin intermediul caruia sa serializati/deserializati obiecte direct intr-o/dintr-o baza de date: se vor salva proprietatile obiectului Java in baza de date ca si obiect PLSQL (in tabela de la punctul 2) si vor putea fi recreate obiectele in Java din datele aflate in baza de date. [Da, stiu ca nu ati facut la Java inca conexiuni cu baze de date, dar acest subpunct este mai mult o componenta de studiu individual in aceasta directie - si va va prinde bine si cand veti ajunge la Java la baze de date] [Partea de Java va fi adaugata ca si comentariu la sfarsitul fisierului sql.]</li>
</ul>


<p>Exemplu: am obiectul masina in Java: marca: Dacia, model: Logan, culoare:</p>
<p>Alb, an fabricatie: 2018. Cand apelez functia java avand ca parametru obiectul</p>
<p>de tip masina, aceasta va scrie in baza de date informatiile despre masina si</p>
<p>eventual va intoarce un identificator din baza de date reprezentand masina (un</p>
<p>camp ID adaugat automat de catre functia PLSQL). In baza de date va fi creat un obiect de tip masina cu proprietatile obiectului java (va avea marca Dacia, modelul Loganm culoarea alba si anul de fabricatie 2018 - aceste date vor putea fi vizualizate printr-un script PLSQL de exemplu - deci nu scrieti un sir de biti reprezentand serializarea standard din Java). La deserializare se intampla</p>
<p>exact invers: dati ID-ul si obtineti obiectul.</p>
<p>Ca fapt divers si ca exercitiu mai interesant, ati putea implementa direct</p>
<p>interfata Serializable din Java pentru a face serializarea/deserializarea.</p>
<p>De data aceasta Java este obligatorie dar nu trebuie sa faceti interfata, e</p>
<p>suficient sa se vada in consola serializarea/deserializarea.</p>


<p><span style="color:red">Observatie:</span> Aceasta este tema numarul 6. Pentru a face upload creati un director in formatul Nume_Prenume_Grupa_6 si puneti in el un singur fisier: Nume_Prenume_Grupa_6_1.sql (ce va contine definitia completa a obiectului impreuna cu scenariile de utilizare) Arhivati cu ZIP directorul si asigurati-va ca arhiva are numele Nume_Prenume_Grupa_6.zip Dupa care folositi scriptul de upload pentru a o uploada. Scriptul de upload il gasiti aici: https://profs.info.uaic.ro/~vcosmin/pagini/upload_psgbd. Partea de Java va fi adaugata ca si comentariu la sfarsitul fisierului sql.</p>
<p>--></p>

<p>= Exercitiu (5pt)=</p>

<p>Creati o clasa la alegere care sa contina macar doua metode si un constructor explicit ( in afara celuil implicit). Tot in cadrul acestei clase scrieti si o metoda de comparare a doua obiecte (MAP sau ORDER), inserati o serie de obiecte intr-o tabela si incercati sa le ordonati dupa coloana in care este introdus obiectul pentru a demonstra ca obiectele pot fi intr-adevar comparate unul cu celalalt. </p>

<p>Construiti o subclasa pentru clasa de mai sus. Suprascrieti macar o metoda din cele existente in clasa de baza. </p>

<p>Construiti un bloc anonim in care sa demonstrati functionalitatea claselor construite.</p>

<p>= Tema (2pt)=</p>

<p>Realizati serializarea unui obiect dintr-o aplicatie proprie (facuta in Java, PHP, Ruby sau alt limbaj ales de voi) intr-o baza de date Oracle (obiectul din OOP va fi stocat ca obiect din PLSQL) si de asemenea deserializarea unui obiect din baza de date inapoi in limbajul respectiv. Tema este echivalenta cu implementarea interfetei Serializable din Java, dar cu stocarea in baza de date a obiectelor.</p>
