<p>= Bulk Binds=</p>
<p>= Prezentare generala  a legaturilor in bloc=</p>
<p>Oracle Database foloseste doua motoare pentru a rula unitati PL / SQL. Motorul PL / SQL ruleaza instructiunile procedurale, iar motorul SQL ruleaza instructiunile SQL. Fiecare instructiune SQL provoaca o comutare de context intre cele doua motoare. Puteti imbunatati foarte mult performanta aplicatiei de baza de date prin minimizarea numarului de comutatoare de context pentru fiecare unitate PL / SQL.</p>
<p>Cand o instructiune SQL ruleaza intr-o bucla care foloseste elemente de colectie ca variabile de legare, numarul mare de comutatoare de context necesare poate provoca performante slabe. Colectiile includ:</p>
<ul>
<li> Tablouri asociative</li>
<li> Tablouri de dimensiuni variabile</li>
<li> Tabelele imbricate</li>
<li> Matrice de gazda</li>
</ul>


<p>Legarea este atribuirea de valori variabilelor PL / SQL in instructiunile SQL. Legarea in bloc leaga o intreaga colectie simultan. Legaturile in bloc trec intreaga colectie intre cele doua motoare intr-o singura operatie.</p>
<p>Care sunt tipurile de legare in bloc:</p>
<ul>
<li> FORALL : INSERT, UPDATE si DELETE care utilizeaza colectii pentru a schimba foarte repede mai multe randuri de date</li>
<li> BULK COLLECT INTO: Instructiuni SELECT care recupereaza mai multe randuri cu o singura preluare, imbunatatind viteza de recuperare a datelor</li>
<li> RETURNING  :Out-Bind</li>
</ul>


<p>Utilitate : </p>
<p>Daca codificam un program care foloseste o multime de preluare de date si bucle, atunci provoaca o multime de comutari contextuale intre motoarele PL / SQL si SQL, reducand astfel performanta considerabil. Aici este utila legarea in bloc. Cand folosim conceptele de legare in masa in programele noastre, elimina comutarea multipla a contextului intre cele doua motoare si creste considerabil performanta programului.</p>


<p>== FORALL ==</p>

<p>Cateva lucruri de stiut despre FORALL:</p>
<ul>
<li> Fiecare instructiune FORALL poate contine doar o singura instructiune DML. Daca bucla dvs. contine doua actualizari si o stergere, atunci va trebui sa scrieti trei instructiuni FORALL.</li>
<li> PL / SQL declara iteratorul FORALL ca intreg, la fel ca in cazul unei bucle FOR. Nu este necesar  si nu ar trebui  sa declarati o variabila cu acelasi nume.</li>
<li> In cel putin un loc din instructiunea DML, trebuie sa faceti referire la o colectie si sa utilizati iteratorul FORALL ca valoare a indexului in acea colectie.</li>
<li> Atunci cand utilizati IN_ low_value. . . sintaxa high_value din antetul FORALL, colectiile la care se face referire in instructiunea FORALL trebuie sa fie umplute dens. Adica, fiecare valoare a indexului intre low_value si high_value trebuie definita.</li>
<li> In cazul in care colectia dvs. nu este umpluta dens, ar trebui sa utilizati INDICATII sau valorile sintaxei din antetul FORALL.</li>
<li> FORALL este una dintre cele mai importante functii in performanta PLSQL. Ar trebui sa o folosim ori de cate ori executam instructiunea DML intr-o bucla.</li>
</ul>


<p>Cream o tabela de test :</p>
<pre><code class="language-sql">CREATE TABLE Bulk_Binds(
  id           NUMBER(10),
comentariu  VARCHAR2(50));
  ALTER TABLE Bulk_Binds ADD (
  CONSTRAINT Bulk_Binds_pk PRIMARY KEY (id));
  SET TIMING ON
</code></pre>


<p>METODA NEEFICIENTA: inseram 10.000 de rânduri folosind FOR..LOOP instrucțiuni regulate .</p>

<pre><code class="language-sql">DECLARE
  TYPE id_type IS TABLE OF Bulk_Binds.id%TYPE;
  TYPE comentariu_type IS TABLE OF Bulk_Binds.comentariu%TYPE;
  t_id id_type := id_type();
  t_comentariu  comentariu_type := comentariu_type();
    CURSOR c_data IS
    SELECT *
    FROM   Bulk_Binds;
BEGIN
  FOR cur_rec IN c_data LOOP
    t_id.extend;
    t_comentariu.extend;
    t_id(t_id.last):= cur_rec.id;
    t_comentariu(t_comentariu.last) := cur_rec.comentariu;
  END LOOP;
END;
/
PL/SQL procedure successfully completed.
Elapsed: 00:00:00.284 
</code></pre>


<p>METODA EFICIENTA: Folosind constructul FORALL pentru a lega în bloc inserțiile</p>

<pre><code class="language-sql">DECLARE
  TYPE id_type  IS TABLE OF Bulk_Binds.id%TYPE;
  TYPE comentariu_type IS TABLE OF Bulk_Binds.comentariu%TYPE;
    t_id  id_type := id_type();
  t_comentariu  comentariu_type := comentariu_type();
BEGIN
  FOR i IN 5001 .. 10000 LOOP
    t_id.extend;
    t_comentariu.extend;
    t_id(t_id.last) := i;
    t_comentariu(t_comentariu.last) := 'comentariu: ' || To_Char(i);
  END LOOP;
   FORALL i IN t_id.first .. t_id.last
    INSERT INTO Bulk_Binds (id, comentariu)
    VALUES (t_id(i), t_comentariu(i));
  COMMIT;
END;
/
PL/SQL procedure successfully completed.
Elapsed: 00:00:00.058
</code></pre>


<h2> BULK COLLECT INTO </h2>
<p>Pentru a profita de procesarea in bloc pentru interogari, pur si simplu puneti BULK COLLECT inainte de cuvantul cheie INTO si apoi furnizati una sau mai multe colectii dupa cuvantul cheie INTO. Iata cateva lucruri de stiut despre cum functioneaza BULK COLLECT:</p>
<ul>
<li> Poate fi utilizat cu toate cele trei tipuri de colectii: tablouri asociative, tabele imbricate si VARIE.</li>
<li> Puteti prelua in colectii individuale (una pentru fiecare expresie din lista SELECT) sau intr-o singura colectie de inregistrari.</li>
<li> Colectia este intotdeauna populata dens, incepand de la valoarea indexului 1.</li>
<li> Daca nu sunt preluate randuri, atunci colectia este golita de toate elementele.</li>
</ul>


<p>Ori de cate ori utilizam clauza BULK COLLECT, atunci este necesara o zona de memorie SGA suficienta. Ori de cate ori nu este disponibila o zona de memorie SGA suficienta, serverul Oracle returneaza o eroare.</p>
<p>Pentru a depasi aceasta problema, Oracle ofera clauza LIMIT impreuna cu declaratia de preluare a cursorului. LIMIT este o clauza optionala care este utilizata pentru a restrictiona numarul de randuri din colectie.</p>
<pre><code class="language-sql">--METODA NEEFICIENTA:
DECLARE
  TYPE id_type IS TABLE OF Bulk_Binds.id%TYPE;
  TYPE comentariu_type IS TABLE OF Bulk_Binds.comentariu%TYPE;
    t_id id_type := id_type();
  t_comentariu  comentariu_type := comentariu_type();
    CURSOR c_data IS
    SELECT *
    FROM   Bulk_Binds;
BEGIN
  FOR cur_rec IN c_data LOOP
    t_id.extend;
    t_comentariu.extend;
    t_id(t_id.last):= cur_rec.id;
    t_comentariu(t_comentariu.last) := cur_rec.comentariu;
  END LOOP;
END;
/
PL/SQL procedure successfully completed.
Elapsed: 00:00:00.060 
</code></pre>


<pre><code class="language-sql">--METODA EFICIENTA:
DECLARE
  TYPE id_type  IS TABLE OF Bulk_Binds .id%TYPE;
  TYPE comentariu_type IS TABLE OF Bulk_Binds .comentariu%TYPE;
    t_id  id_type;
  t_comentariu  comentariu_type;
BEGIN
  SELECT id, comentariu 
  BULK COLLECT INTO t_id, t_comentariu FROM Bulk_Binds ;
END;
/
PL/SQL procedure successfully completed.
Elapsed: 00:00:00.013
</code></pre>


<p>Autor: Mototolea Cosmin David</p>
