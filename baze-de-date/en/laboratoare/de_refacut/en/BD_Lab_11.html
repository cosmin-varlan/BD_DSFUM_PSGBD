<p>=Substitution variables in SQL*Plus=</p>

<p>Substitution variables can be used to store constants, conditions required in the WHERE clause, field names used in the ORDER BY cluase or in the SELECT list.  </p>

<p>Substitution variables are preceded by symbol <b>&</b> and when executing the query, SQLPlus will ask the user for the values to be used for the substitution variables.</p>

<p>Example 1:</p>
<pre><code class="language-sql">SELECT *
    FROM students
    WHERE year=&year AND first_name LIKE '&firstName'

<p>Example 2:</p>
<pre><code class="language-sql">SELECT fname, &field_to_show
    FROM students
    WHERE &condition2
    ORDER BY &field_to_sort;

<p>Execute the queries above several times, using various values for the substitution variables. Verify the results.</p>

<p>Substitution variables can be declared and instantiated in advance, case in which SQLPlus will not ask for the value when executing the query: </p>
<pre><code class="language-sql">DEFINE field=lname
SELECT fname, &field
    FROM students
    ORDER BY &field;

<p>The variable is stored during the current session until it is eliminated with the UNDEFINE command or until the session is closed.</p>
<pre><code class="language-sql">UNDEFINE field

<p>DEFINE and UNDEFINE commands are specific to the SQL*Plus tool and not to the SQL language.</p>

<p>For more about substitution variables read https://blogs.oracle.com/opal/entry/sqlplus_101_substitution_varia</p>

<p>= DML statements - Modifying data =</p>
<p>So far,you worked only with queries - SELECT phrases which search for data in the database. This section is dedicated to DML commands that modify data.</p>

<h2>Inserting records</h2>
<p>Inserting new records in the database is made with the INSERT statement which has two forms:</p>
<p>{| border="1"</p>
<p>|<pre>INSERT INTO table_name [ (column_list) ]</p>
<p>      VALUES (value_list)</pre></p>
<p>| INSERT INTO courses VALUES(30, 'Mach. Learn.', 3, 1, 5);<br></p>
<p>INSERT INTO courses (id_course, course_title) VALUES(31, 'NoSQL');</p>
<p>|-</p>
<p>|<pre>INSERT INTO table_name [ (column_list) ]</p>
<p>   select_phrase	</pre></p>
|
<p> INSERT INTO grades</p>
<p> SELECT id_stud, 30, 10, SYSDATE</p>
<p>   FROM students</p>
<p>   WHERE year=3;</p>
<p>|}</p>

<h3>SEQUENCES===</h3>
<p>Many times, we need to create synthetic attributes to play as keys in the database, storing unique values in the table.Sequences allow us to automatically generate integer unique values when inserting records. </p>

<p>The syntax for creating sequences:</p>
<pre><code class="language-sql">CREATE SEQUENCE sequence_name
  [INCREMENT BY n]               -- step
  [START WITH n1]                -- starting value
  [MAXVALUE n_max | NOMAXVALUE]  -- stop value
  [MINVALUE n_min | NOMINVALUE]  -- minimum value (lists can consist of descending values)
  [CYCLE | NOCYCLE]              -- if the series is restarted when reaching min/max

<p>The NEXTVAL command generates the next number in the series and CURRVAL returns the current value. NEXTVAL must be executed before the list contains any number.</p>

<p>Example:</p>
<pre><code class="language-sql">CREATE SEQUENCE s1
  INCREMENT BY 2
  START WITH 10
  MAXVALUE 15;

SELECT s1.NEXTVAL FROM DUAL; --execute it repeatedly; when does it raise errors?

<p>For more about sequences, read https://docs.oracle.com/cd/B12037_01/server.101/b10759/statements_6014.htm</p>

<h3>Exercises===</h3>
<p>How can be a sequence used for inserting records?</p>
<p>Answer by creating a sequence to help you inserting new courses with unique IDs, with consecutive entries starting with value 1. Insert 3 new courses with the id generated by sequence.</p>

<h2>Updating records</h2>
<p>{| border=1</p>
<p>|<pre>UPDATE table_name [alias]</p>
<p>  SET column_name1 = value1</p>
<p>     [, column_name2 = value2...]</p>
<p>      [WHERE condition]</pre>	</p>
<p>|UPDATE students </p>
<p>SET scholarship=scholarship*0.15</p>
<p>WHERE scholarship<300;</p>
<p>|-</p>
<p>|<pre>UPDATE table_name [alias]</p>
<p>  SET (column_name1 [,column_name2]...) = (subquery)</p>
<p>    [WHERE condition]</pre></p>
|
<p>|}</p>
<h3>Exercises===</h3>
<p>#Update the scholarship for the students who have at least one grade equal to 10. These students will earn 500RON.</p>
<p><!--#All the students earn a scholarship which depends on their average grade and is computed as 100*average_grade. Make the updates in the database.--></p>

<h2>Deleting records</h2>
<p>{| border=1</p>
<p>|<pre>DELETE FROM table_name </p>
<p>  [WHERE condition]</pre></p>
<p>|DELETE FROM grades WHERE value < 5;</p>
<p>|}</p>

<h3>Exercises===</h3>
<p>Delete all the students who haven't received any grade.</p>

<p>= DDL statements - creating/modifying data structures =</p>
<p>These commands aim at creating or deleting tables (or other types of objects), and also at modifying the structure of the existing tables (objects). They form the DDL component (Data Definition Language) of the SQL language.</p>

<h2>CREATE TABLE AS</h2>
<p>The commands for creating tables were explained at the course, detailing the constraints that can be enforced on the data. Here we cover only the CREATE command using subqueries.</p>

<pre><code class="language-sql">CREATE TABLE table_name[(col1, col2,...)] [AS] select_phrase;

<p>The command is similar to the one used to create the view, the difference consisting that when creating a table it is filled with data and the links to the base tables is not preserved. </p>

<h3>Exercises===</h3>
<p>Execute the ROLLBACK command (simply type ROLLBACK). Than create a table to store the first_name, last_name, scholarship and the average grade for each student. </p>

<h2>ALTER TABLE</h2>
<p>The structure of the existing tables can be modified, even if the table contains data.The changes may imply adding new columns, deleting existing columns, modifying the definition of a column (the type and the constraints), renaming a column, renaming the table, adding or deleting constraints (candidate keys, primary keys, foreign keys, NOT NULL constraints, CHECK).</p>

<p>The commands are the following: </p>
<p>{| border=1</p>
<p>|ALTER TABLE table_name ADD (col1 definition_col1 [,col2 definition_col2....]) </p>
<p>||<pre>ALTER TABLE courses ADD (abreviation CHAR(2) NULL, </p>
<p>                 description VARCHAR(40) DEFAULT 'mandatory course');</pre></p>
<p>|-</p>
<p>|ALTER TABLE table_name DROP COLUMN col</p>
<p>||<pre>ALTER TABLE courses DROP COLUMN description;</pre></p>
<p>|-</p>
<p>|ALTER TABLE table_name MODIFY (col1 definitie_col1 [,col2 definitie_col2....])</p>
<p>||<pre>ALTER TABLE instructors MODIFY (fname VARCHAR(20), </p>
<p>                            lname VARCHAR(20));</pre></p>
<p>|-</p>
<p>|ALTER TABLE table_name RENAME COLUMN old_col TO new_col</p>
<p>||<pre>ALTER TABLE grades RENAME COLUMN value TO grade;</pre></p>
<p>|-</p>
<p>|ALTER TABLE old_table_name RENAME TO new_table_name</p>
<p>||<pre>ALTER TABLE instructors RENAME TO teachers;</pre></p>
<p>|-</p>
<p>|ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition;</p>
<p>||<pre>ALTER TABLE students ADD CONSTRAINT </p>
<p>     pk_studs PRIMARY KEY (id_stud);</pre></p>
<p><pre>ALTER TABLE grades ADD CONSTRAINT </p>
<p>     fk_studs FOREIGN KEY (id_stud) </p>
<p>           REFERENCES students(id_stud) ON DELETE CASCADE;</pre></p>
<p>|-</p>
<p>|ALTER TABLE table_name DROP CONSTRAINT constraint_name;</p>
<p>||<pre>ALTER TABLE grades DROP CONSTRAINT fk_studs;</pre></p>
<p>|}</p>

<h3>Exercices===</h3>
<p>Execute again the script here: http://profs.info.uaic.ro/~pmihaela/faculty.sql<br></p>
<p>#Add the primary key constraints for tables Students, Instructors, Courses.</p>
<p>#Add the referential constraints for tables Grades and Teaching. When deleting an instroctor in table Instructors, the id of the deleted instructor will be set to NULL. When deleting a course in table Courses, in table Teaching the record referencing the deleted course will also be deleted. Write some DELETE statements for the referenced tables and study the behavior. </p>
<p>#Impose the constraint that a student will not have more than a grade to each course. </p>
<p>#Impose the constraint that the grade values will be in range 1-10.</p>

<p>=Transactions=</p>
<p>A transaction represents a group of commands for modifying data (DML statements) that must be executed together, in order to guarantee data consistency. Failing to execute one statement must determines the system to restore the initial state from the beginning of the transaction. </p>

<p>A transaction begins with the first DML statement and ends when a COMMIT or ROLLBACK command is met, or when a DDL command is launched, when closing the session or when a system error appears. </p>

<p>The ROLLBACK command ends the transaction restoring the initial state. A system failure also results a ROLLBACK, restoring the state of the database at the moment before starting the transaction; this is how data integrity is ensured. The rest of the situations which end a transaction make the results of the DML permanent in the database without the possibility to restore intermediate states.</p>

<p>Once a transaction is over, another one begins.</p>

<p>During this lab, you executed the ROLLBACK command before experimenting with CREATE TABLE, ie before launching the first DDL statement. The result was the restoration of the state of the database from the beginning of the session. If the ROLLBACK command would not have been executed, the changes made to the data would have become permanent in the moment the DDL command had been executed (as previously specified, any DDL command ends the current transaction marking the previous changes in data as permanent).</p>

<p>During a transaction, several markers can be placed helping us to restore intermediate states. Adding an indicator is made with the command <pre>SAVEPOINT indicator_name</pre> and restoring the state of the database for that moment is made with <pre>ROLLBACK TO SAVEPOINT indicator_name</pre>.</p>

<p>Any DDL command is considered to be a transaction.</p>

<h3>Exercises===</h3>
<p># Ensure that you start a new transaction.</p>
<p># Delete all the records in table Instructors.</p>
<p># Insert an instructor.</p>
<p># Mark its current state as 's1'.</p>
<p># Change the name of the inserted instructor.</p>
<p># Query the data.</p>
<p># Restore s1.</p>
<p># Query the data.</p>
<p># Restore the state at the beginning of the transaction.</p>
