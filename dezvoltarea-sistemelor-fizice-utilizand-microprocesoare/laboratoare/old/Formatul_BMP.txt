==Introducere==
Formatul de fișier <b>BMP</b> (en. <b>Bitmap</b> - hartă de biți), cunoscut de asemenea și ca fișier imagine Bitmap sau formatul de fișier <b>DIB</b> (en. <b>Device Independent Bitmap</b> - „bitmap” independent de dispozitiv) sau pur și simplu <b>Bitmap</b>, este un format de fișier imagine de tip rastru folosit pentru a stoca imagini digitale independent de dispozitivul de afișare (cum ar fi un adaptor grafic) în special pe sistemele de operare Microsoft Windows și OS/2.

Formatul de fișier BMP este capabil de a stoca imagini digitale bidimensionale de lățime, înălțime și rezoluție arbitrare, monocrome sau color, de variate profunzimi ale culorii iar opțional cu comprimare de date, canale alfa și profile de culoare.

==Structură==
[[Fișier:Structura-bitmap.JPG|300px|thumb|upright|alt=Structură BMP|Structură BMP (poza preluată de pe http://upm.ro/intranet/ecalin/cd_educational/cd/test_multim/lab_scmm/formatul_bmp.htm)]]

Formatul se împarte în trei părţi mai importante:
* prima se numeşte <b>BitMapHeader</b>, şi ne furnizează importante informaţii privitoare la lungimea fişierului, numărul de pixeli dintr-o linie de imagine, numărul de linii folosite, numărul de culori şi altele
* în a doua parte vom găsi informaţii privitoare la paleta de culori <b>RGB QUAD</b>
* iar în ultima este prezenta informaţia de imagine <b>INFO IMG</b> fără terminator între linii.

===Câmpurile structurii BitmapFileHeader===
* Offset: 00, număr octeți: 2, nume: "<b>bftype</b>": reprezintă tipul fişierului (BMP), în Windows 3.x sau OS/2 aici se află depusă valoarea (4D42h)
* Offset: 02, număr octeți: 4, nume: "<b>bfsize</b>": reprezintă mărimea fişierului în bytes (maxim ffffffffh)
* Offset: 06, număr octeți: 2, nume: "<b>bfReserved1</b>": rezervat utilizatorului (0000h) 
* Offset: 08, număr octeți: 2, nume: "<b>bfReserved2</b>": rezervat utilizatorului (0000h)
* Offset: 10, număr octeți: 4, nume: "<b>bfOffBits</b>": reprezintă offsetul de la începutul fişierului de unde începe structură de date imagine BITMAP în bytes.
===Câmpurile structurii BitmapInfoHeader===
* Offset: 14, număr octeți: 4, nume: "<b>biSize</b>": reprezintă dimensiunea BITMAPINFOHEADER, în octeți
* Offset: 18, număr octeți: 4, nume: "<b>biWidth</b>": reprezintă lungimea imaginii în pixeli (numărul de pixeli dintr-o linie)
* Offset: 22, număr octeți: 4, nume: "<b>biHeight</b>": reprezintă înălțimea imaginii în pixeli (numărul de linii)
* Offset: 26, număr octeți: 2, nume: "<b>biPlanes</b>": reprezintă numărul de planuri de culoare (R,G,B); pentru 256 culori nu există planuri de culoare ci paletă de culori, deci această variabilă se află setată la 01h
* Offset: 28, număr octeți: 2, nume "<b>biBitCount</b>": reprezintă numărul de biți necesari pentru memorarea unui pixel, care specifică indirect câte culori conține informația BitMap. Valorile uzuale sunt:
** <b>1</b>:Bitmap monocrom 2 colori
** <b>4</b>:BMP cu maxim 16 culori
** <b>8</b>:BMP cu maxim 256 culori
** <b>24</b>:BMP true color maxim 16,7 milioane culori . În acest caz nu există o tabelă de culori în structura BitMap, informația de imagine fiind organizată în trei plane de culoare
* Offset: 30, număr octeți: 4, nume: "<b>biCompression</b>": reprezintă tipul compresiei utilizate, valorile standard sunt:
** <b>BIRGB</b> (valoare 00h) BitMap necomprimat (4 biți/pixel).
** <b>BIRLE 4</b> (valoare 01h) se utilizează o codare cu pas variabil cu maxim 16 culori (4 biți/pixel)
** <b>BIRLE 8</b> (valoare 02h) se utilizează o codare cu pas variabil cu maxim 256 culori (8 biți/pixel)
* Offset: 34, număr octeți: 4, nume: "<b>bisizeImage</b>": reprezintă mărimea structurii BMP în bytes
* Offset: 38, număr octeți: 4, nume: "<b>biXPelsPerMeter</b>": rezoluția orizontală în pixeli/metru
* Offset: 42, număr octeți: 4, nume: "<b>biYPelsPerMeter</b>": rezoluția verticală în pixeli/metru
* Offset: 46, număr octeți: 4, nume: "<b>biClvUsed</b>": numărul culorilor utilizate
* Offset: 50, număr octeți: 4, nume: "<b>biClvImportant</b>": numărul de culori semnificative în reprezentarea imaginii
===Structura paletei de culori===
Această informație începe de la offset: 54 şi este cunoscută sub numele de RGB QUAD, fiind organizată în partiții de patru octeți, câte o partiție pentru fiecare culoare folosită, şi un octet este rezervat utilizatorului. Să presupunem astfel că avem un număr de 236 culori folosite, (indicat la poziția 46 în BitMap Header) vor rezulta în RGB QUAD 236 partiții a câte patru octeți fiecare, aceasta fiind de fapt şi lungimea RGB QUAD pentru imaginea citită. Această lungime este diferită de la o imagine la alta, iar în cazul în care avem o imagine cu o singură culoare, RGB QUAD are lungimea de patru octeți. Între aceştia se va găsi informația care face referire la modul de programare a paletei de culori (doar în cazul în care avem o imagine cu maxim 256 culori) şi arată astfel:

* Offset: 00h, număr octeți: 1, nume: "<b>rgbBlue</b>": intensitatea componentei de bază pentru albastru
* Offset: 01h, număr octeți: 1, nume: "<b>rgbGreen</b>": intensitatea componentei de bază pentru verde
* Offset: 02,  număr octeți: 1, nume: "<b>rgbRed</b>": intensitatea componentei de bază pentru roşu
* Offset: 03h, număr octeți: 1, nume: "<b>rgbReserved</b>": nu este folosit, (00h)
==Format==
===Formatul BitMap necomprimat===
Cu valoare zero pentru "biCompression", datele sunt ordonate de jos în sus, primul pixel care reprezintă un pixel din imagine fiind cel indicat de "bfOffBits"  şi care este pixelul din stânga jos de coordonată (0, MAXy). Astfel primul pixel citit de aici va fi pus de fapt jos şi nu sus pe ecran. Rezultă deci, că în mod normal, imaginea va apărea pe ecran de jos în sus. 
===Formatul BitMap de 24 biţi===
Are o structură cu totul specială care se pretează unor imagini în "TRUE COLOR" de o calitate superioară. În acest caz nu mai există o informaţie referitoare la paleta de culori deoarece ea practic nu mai este necesară, calculatorului lipsindu-i o paletă de culori. În acest caz informaţia de culoare este memorată pentru fiecare pixel în parte. Se poate practic reprezenta orice imagine fără a programa paleta, acest lucru fiind posibil datorită numărului foarte mare de combinaţii de culori (16 milioane - 224) care pot descrie în condiţii foarte bune, folosind 24 biţi.

Informaţia citită din fişierul BMP format 24 biţi reprezintă direct cele trei componente de culoare R G B care pot lua valori între 0 şi 255, putând în acest caz avea un număr de 256 nivele diferite de gri. Avantajul folosirii acestui mod grafic iese în evidenţă la vizualizarea formatelor AVI (secvenţe video) care memorează o secvenţă de imagine, fără a mai sintetiza o paletă de culori care ar creşte ca mărime o dată cu creşterea duratei secvenţei. Aceste moduri grafice sunt cele folosite în High Digital Television având posibilitatea redării oricărui conţinut de culoare dintr-o imagine.

==Dezavantaj==
Deși imaginile digitale salvate ca .bmp au o calitate medie spre înaltă, dezavantajul lor rezultă în dimensiunea supraevaluată. De aceea formatul nici nu mai este folosit decât pentru pictograme și imagini de dimensiuni reduse.

==Slideshow imagini BMP folosind Arduino==
[[Fișier:LCD.jpg|230px|thumb|upright|alt=TFT LCD|TFT LCD (poza preluată de pe https://www.tdegypt.com/product/24-tft-lcd-touch-shield-arduino/)]]
Pe lângă placa Arduino am folosit și [https://www.tdegypt.com/product/24-tft-lcd-touch-shield-arduino/ <b>2.4” TFT LCD Touch Shield for Arduino</b>]. Pentru a putea fi utiliat, LCD-ul are nevoie de o bibliotecă ce nu există în IDEE: <b>SPFD5408</b> ce poate fi descărcată de [https://github.com/JoaoLopesF/SPFD5408 <i>aici</i>]. După ce va fi descărcată, din IDEE se va accesa meniul Sketch --> Include Library --> Add .ZIP Library, se va selecta fișierul .ZIP descărcat și se va da click pe Open.

Pe lângă Arduino și LCD, este nevoie și de un card microSD (pe care se vor pune pozele în format BMP). Pentru a putea utiliza cardul, este nevoie să fie incluse bibliotecile SD.h și SPI.h care se găsesc deja instalate în IDEE.

Pentru a putea crea slideshow-ul am căutat pe internet imagini cu rezoluția de 240x320 pixeli (fie în formatul .bmp fie în alt format iar apoi le-am făcut conversie la .bmp) și le-am pus pe card (în directorul rădăcină). Se pot folosi și imagini la altă rezoluție dar nu vor fi afișate corect (ca update, se poate îmbunătăți codul printr-o funcție care să redimensioneze imaginile la rezoluția suportată de ecran). 

==Codul utilizat==
<i>Ca mențiune, <b>SD_CS</b> se mută pe pinul 10, nu pe 4 ca la shield-ul Ethernet (acolo ca să putem accesa cardul trebuia să fie setat pe pinul 4).</i>

<source lang="c">
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_TFTLCD.h> // Hardware-specific library
#include <SD.h>
#include <SPI.h>

#define LCD_CS A3 // Chip Select goes to Analog 3
#define LCD_CD A2 // Command/Data goes to Analog 2
#define LCD_WR A1 // LCD Write goes to Analog 1
#define LCD_RD A0 // LCD Read goes to Analog 0

// For the Arduino Uno, Duemilanove, Diecimila, etc.:
//   D0 connects to digital pin 8  (Notice these are
//   D1 connects to digital pin 9   NOT in order!)
//   D2 connects to digital pin 2
//   D3 connects to digital pin 3
//   D4 connects to digital pin 4
//   D5 connects to digital pin 5
//   D6 connects to digital pin 6
//   D7 connects to digital pin 7


//  connect the SD card with DI going to pin 11, DO going to pin 12 and SCK going to pin 13 (standard)
#define SD_CS 10     // Set the chip select line to whatever you use (10 doesnt conflict with the library)

// In the SD card, place 240x320 pixels BMP files


// our TFT wiring
Adafruit_TFTLCD tft(LCD_CS, LCD_CD, LCD_WR, LCD_RD, A4);

void setup()
{
  Serial.begin(9600);

  tft.reset();

  uint16_t identifier = tft.readID();

  if(identifier == 0x9325) {
    Serial.println(F("Found ILI9325 LCD driver"));
  } else if(identifier == 0x9328) {
    Serial.println(F("Found ILI9328 LCD driver"));
  } else if(identifier == 0x7575) {
    Serial.println(F("Found HX8347G LCD driver"));
  } else if(identifier == 0x9341) {
    Serial.println(F("Found ILI9341 LCD driver"));
  } else if(identifier == 0x8357) {
    Serial.println(F("Found HX8357D LCD driver"));
  } else {
    Serial.print(F("Unknown LCD driver chip: "));
    Serial.println(identifier, HEX);
    Serial.println(F("If using the Adafruit 2.8\" TFT Arduino shield, the line:"));
    Serial.println(F("  #define USE_ADAFRUIT_SHIELD_PINOUT"));
    Serial.println(F("should appear in the library header (Adafruit_TFT.h)."));
    Serial.println(F("If using the breakout board, it should NOT be #defined!"));
    Serial.println(F("Also if using the breakout, double-check that all wiring"));
    Serial.println(F("matches the tutorial."));
    return;
  }

  tft.begin(identifier);

  Serial.print(F("Initializing SD card..."));
  if (!SD.begin(SD_CS)) {
    Serial.println(F("failed!"));
    return;
  }
  Serial.println(F("OK!"));
}


void loop()
{
  File dir;
  dir=SD.open('/');
  while (true) {

    File entry =  dir.openNextFile();
    if (! entry) {
      // no more files
      break;
    }
    Serial.print(entry.name());
    if (!entry.isDirectory()) {
      bmpDraw(entry.name(), 0, 0);
     delay(1500); //to stop the image for 1.5 seconds
    }
    entry.close();
  }
   
}


#define BUFFPIXEL 20

void bmpDraw(char *filename, int x, int y) {

  File     bmpFile;
  int      bmpWidth, bmpHeight;   // W+H in pixels
  uint8_t  bmpDepth;              // Bit depth (currently must be 24)
  uint32_t bmpImageoffset;        // Start of image data in file
  uint32_t rowSize;               // Not always = bmpWidth; may have padding
  uint8_t  sdbuffer[3*BUFFPIXEL]; // pixel in buffer (R+G+B per pixel)
  uint16_t lcdbuffer[BUFFPIXEL];  // pixel out buffer (16-bit per pixel)
  uint8_t  buffidx = sizeof(sdbuffer); // Current position in sdbuffer
  boolean  goodBmp = false;       // Set to true on valid header parse
  boolean  flip    = true;        // BMP is stored bottom-to-top
  int      w, h, row, col;
  uint8_t  r, g, b;
  uint32_t pos = 0, startTime = millis();
  uint8_t  lcdidx = 0;
  boolean  first = true;

  if((x >= tft.width()) || (y >= tft.height())) return;

  Serial.println();
  Serial.print(F("Loading image '"));
  Serial.print(filename);
  Serial.println('\'');
  // Open requested file on SD card
  if ((bmpFile = SD.open(filename)) == NULL) {
    Serial.println(F("File not found"));
    return;
  }

  // Parse BMP header
  if(read16(bmpFile) == 0x4D42) { // BMP signature
    Serial.println(F("File size: ")); Serial.println(read32(bmpFile));
    (void)read32(bmpFile); // Read & ignore creator bytes
    bmpImageoffset = read32(bmpFile); // Start of image data
    Serial.print(F("Image Offset: ")); Serial.println(bmpImageoffset, DEC);
    // Read DIB header
    Serial.print(F("Header size: ")); Serial.println(read32(bmpFile));
    bmpWidth  = read32(bmpFile);
    bmpHeight = read32(bmpFile);
    if(read16(bmpFile) == 1) { // # planes -- must be '1'
      bmpDepth = read16(bmpFile); // bits per pixel
      Serial.print(F("Bit Depth: ")); Serial.println(bmpDepth);
      if((bmpDepth == 24) && (read32(bmpFile) == 0)) { // 0 = uncompressed

        goodBmp = true; // Supported BMP format -- proceed!
        Serial.print(F("Image size: "));
        Serial.print(bmpWidth);
        Serial.print('x');
        Serial.println(bmpHeight);

        // BMP rows are padded (if needed) to 4-byte boundary
        rowSize = (bmpWidth * 3 + 3) & ~3;

        // If bmpHeight is negative, image is in top-down order.
        // This is not canon but has been observed in the wild.
        if(bmpHeight < 0) {
          bmpHeight = -bmpHeight;
          flip      = false;
        }

        // Crop area to be loaded
        w = bmpWidth;
        h = bmpHeight;
        if((x+w-1) >= tft.width())  w = tft.width()  - x;
        if((y+h-1) >= tft.height()) h = tft.height() - y;

        // Set TFT address window to clipped image bounds
        tft.setAddrWindow(x, y, x+w-1, y+h-1);

        for (row=0; row<h; row++) { // For each scanline...
          // Seek to start of scan line.  It might seem labor-
          // intensive to be doing this on every line, but this
          // method covers a lot of gritty details like cropping
          // and scanline padding.  Also, the seek only takes
          // place if the file position actually needs to change
          // (avoids a lot of cluster math in SD library).
          if(flip) // Bitmap is stored bottom-to-top order (normal BMP)
            pos = bmpImageoffset + (bmpHeight - 1 - row) * rowSize;
          else     // Bitmap is stored top-to-bottom
            pos = bmpImageoffset + row * rowSize;
          if(bmpFile.position() != pos) { // Need seek?
            bmpFile.seek(pos);
            buffidx = sizeof(sdbuffer); // Force buffer reload
          }

          for (col=0; col<w; col++) { // For each column...
            // Time to read more pixel data?
            if (buffidx >= sizeof(sdbuffer)) { // Indeed
              // Push LCD buffer to the display first
              if(lcdidx > 0) {
                tft.pushColors(lcdbuffer, lcdidx, first);
                lcdidx = 0;
                first  = false;
              }
              bmpFile.read(sdbuffer, sizeof(sdbuffer));
              buffidx = 0; // Set index to beginning
            }

            // Convert pixel from BMP to TFT format
            b = sdbuffer[buffidx++];
            g = sdbuffer[buffidx++];
            r = sdbuffer[buffidx++];
            lcdbuffer[lcdidx++] = tft.color565(r,g,b);
          } // end pixel
        } // end scanline
        // Write any remaining data to LCD
        if(lcdidx > 0) {
          tft.pushColors(lcdbuffer, lcdidx, first);
        } 
        Serial.print(F("Loaded in "));
        Serial.print(millis() - startTime);
        Serial.println(" ms");
      } // end goodBmp
    }
  }

  bmpFile.close();
  if(!goodBmp) Serial.println(F("BMP format not recognized."));
}

// These read 16- and 32-bit types from the SD card file.
// BMP data is stored little-endian, Arduino is little-endian too.
// May need to reverse subscript order if porting elsewhere.

uint16_t read16(File f) {
  uint16_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read(); // MSB
  return result;
}

uint32_t read32(File f) {
  uint32_t result;
  ((uint8_t *)&result)[0] = f.read(); // LSB
  ((uint8_t *)&result)[1] = f.read();
  ((uint8_t *)&result)[2] = f.read();
  ((uint8_t *)&result)[3] = f.read(); // MSB
  return result;
}

</source>
==Linkuri utile==
* http://ctmtc.utcluj.ro:8080/sites/pni/SACCDAV/Laborator/Laborator01.pdf?Mobile=1&Source=%2Fsites%2Fpni%2FSACCDAV%2F_layouts%2Fmobile%2Fview.aspx%3FList%3Da9969b83%252D7960%252D4af5%252Da28f%252Dd4e926cef274%26View%3D6d5d4b38%252D98cb%252D46e7%252D94ec%252Ddef35036595e%26CurrentPage%3D1
* https://ro.wikipedia.org/wiki/BMP_(format_fișier)
* http://paulbourke.net/dataformats/bmp/
* http://upm.ro/intranet/ecalin/cd_educational/cd/test_multim/lab_scmm/formatul_bmp.htm
* https://www.tdegypt.com/product/24-tft-lcd-touch-shield-arduino/
* http://www.instructables.com/id/How-to-use-24-inch-TFT-LCD-SPFD5408-with-Arduino-U/
