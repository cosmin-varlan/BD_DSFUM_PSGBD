== Muzica ==

Notele muzicale sunt obtinute facand o oscilatie pe un anumit pin cu o anumita frecventa. Ati vazut probabil cat de repede poate oscila valoarea unui pin si de aici va puteti inchipui si ca se pot face oscilatii care transmise unui buzzer sa il faca sa redea diverse note muzicale. 

Pentru cei mai muzicieni dintre voi, Arduino poate si canta (evident cu putin efort). Puteti gasi un exemplu in acest sens in sectiunea de Exemple a IDEului (Examples->Digital->toneMelody). Daca ati deschis acest exemplu, automat se va deschide si un fisier "pitches.h" continand definitiile fiecarei note. 

Foarte interesant este documentul de [[https://profs.info.uaic.ro/~vcosmin/pagini/resurse_arduino/docs/Notiuni%20generale%20de%20teorie%20muzicala158.pdf aici]].

<source lang="c">
#define p_tip 4
#define p_r1 5
#define p_r2 6
#define p_sleeve 7


// note redefinite de Stolniceanu Stefan dupa fisierul pitches.h (din Examples->Digital->toneMelody)
#define NOTE_D4  294
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_G4  392
#define NOTE_A4  440 // nota LA - interesant de citit si asta: http://dantanasescu.ro/2012/01/07/440-hz-frecventa-care-dezbina.html
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_D5  587

// vedeti mai mult in exemple -> Exemple -> Digital -> ToneMelody (are un pitches.h)


int pauza_intre_note = 250;
int note[] = {
    NOTE_D4, NOTE_E4, NOTE_F4, NOTE_G4, NOTE_A4, NOTE_B4,
    NOTE_C5, NOTE_D5
};

void setup() {
  for(int i=4; i<=7; i++)
  {
    pinMode(i,OUTPUT);
    digitalWrite(i,LOW);
  }
}

void loop() {
  for (int nota_curenta = 0; nota_curenta < 8; nota_curenta++) {
    tone(p_tip, note[nota_curenta], pauza_intre_note); // 3 = pinul cu buzzer-ul, nota, delay
    delay(300);
    noTone(p_tip);
  }  

  for (int nota_curenta = 7; nota_curenta >= 0; nota_curenta--) {
    tone(p_tip, note[nota_curenta], pauza_intre_note); // 3 = pinul cu buzzer-ul, nota, delay
    delay(300);
    noTone(p_tip);
  }    
  delay (1000);
}

</source>
Si acum ca ati vazut ce simplu este sa cantati notele de la do pana la do, iata doua exemple mai complexe: [[SW]] [[HarryPotter]] :)

Tinand cont de cele scrise in documentul [[https://profs.info.uaic.ro/~vcosmin/pagini/resurse_arduino/docs/Notiuni%20generale%20de%20teorie%20muzicala158.pdf PDF]], mai exact la pagina 2 si respectiv 6, puteti observa cat trebuie sa dureze o nota: 

* nota desenata ca un cerculet simplu, fara nici o codita reprezinta un ton intreg. O sa convenim sa consideram ca dureaza un timp de 32.
* nota desenata ca un cerculet cu codita dureaza jumate din timp: 16
* nota desenata ca un cerc plin cu codita (♩) = un sfert dintr-un ton: 8
* nota desenata ca un cerc plin cu codita si un stegulet (♪) o optime dintr-un ton: 4
* nota desenata ca un cerc plin cu codita si doua stegulete reprezinta o saisprezecime dintr-un ton: 2
* nota desenata ca un cerc plin cu codita sicu trei stegulete reprezinta a 32-a parte dintr-un ton: 1

In plus, daca nota este urmata imediat de un puncticel negru, la timpul ei se mai adauga jumatate. De exemplu un cerculet plin, cu codita si avand un punct dupa el nu mai are valoarea de 8 ci de 12 (♪. = 12).

Sa consideram urmatoarea partitura, reprezentand imnul Republicii Socialiste Romania (sau imnul dinainte de '89), pe care toata lumea il stia sub denumirea de "Trei culori" si care este de fapt denumit "Imnul tricolorului" (da, stiu, sunt un bosorog cu reminiscente comuniste):

[[Fișier:Tricolorul-porumbescu.jpg|800px|alt=Tricolorul|Tricolorul]]
(imagine preluata de [[http://www.rador.ro/2016/05/25/portret-ciprian-porumbescu-o-viata-plina-de-cautari-bucurii-si-neimpliniri-curmata-mult-prea-devreme/ aici]])

(Totusi Cantecul Tricolorului a fost scris de Ciprian Porumbescu... care nu era chiar Gutza sau Adrian Copchilu' Minune). 

Sa vedem cum am putea scrie aceasta partitura si sa il aducem din nou la gloria de odinioara, prin intermediul Arduinoului.

In primul rand vom defini notele pe care le vom folosi:

<source lang="c">
// note scrise de Stefan Stolniceanu dupa pitches.h din Examples->Digital->toneMelody:
#define do  131
#define do_diez 139
#define re  147
#define re 156
#define mi  165
#define fa  175
#define fa_diez 185
#define sol  196
#define sol_diez 208
#define la  220
#define la_diez 233
#define si  247
 
// aici incepe cheia Sol (octava lui C4):
#define Do  262 
#define Do_diez 277
#define Re  294
#define Re_diez 311
#define Mi  330
#define Fa  349
#define Fa_diez 370
#define Sol  392 
#define Sol_diez 415
#define La  440
#define La_diez 466
#define Si  494
 
// aici incepe cheia sol cu o octava mai sus (octava lui C5)
#define DO  523
#define DO_diez 554
#define RE  587
#define RE_diez 622
#define MI  659
#define FA  698
#define FA_diez 740
#define SOL  784
#define SOL_diez 831
#define LA  880
#define LA_diez 932
#define SI  988
</source>


In partitura apar toate notele din cheia Sol impreuna cu nota #Sol - un Sol ridicat cu un semiton precum si nota re din urmatoarea gama (cele doua au fost adaugate la sfarsit drept dSol respectiv RE si au fost inspirate din pitch.h din care am scazut valoarea 8). 

Urmand exemplul de mai sus, vom construi sirul de note:

* Prima nota este nota do, ca o bulinuta si cu stegulet. Acest lucru inseamna ca timpul asociat ei este de 4 plus inca jumatate: 6. Deci prima nota este Do timp de 6 unitati.
* Urmeaza nota Do (din nou), de aceasta data cu o masura de 2 unitati (conform celor scrise mai sus) - pentru ca este ca o bulinita cu doua stegulete :)
* Urmeaza nota Fa pe 12 unitati de timp, 
* Apoi iarasi Fa pe 4 unitati. 

Pentru a va fi mai usor, incercati sa scrieti pe un nou rand fiecare interval din portativ. Acum tocmai s-a incheiat un astfel de interval, deci puteti sari la un nou rand.

Mie mi-a fost mai usor sa scriu timpul pentru nota imediat dupa nota (deci in acelasi sir). Desi nu e chiar ok - pentru ca sirul se numeste "note" si nu "note_cu_timpi", pentru a putea canta notele va trebui sa sarim in sir din doua in doua pozitii si vom gasi notele. Iata sirul de note pentru intreaga partitura (fiecare interval este pe un nou rand, dupa ce s-a terminat un portativ, am lasat un rand liber):

<source lang="c">
int note[] = {
    Do,6,   Do,2,  Fa,12,  Fa,4, 
    Sol,6,  Do,2,  La,8,   Fa,8,
    Fa,6,   Mi,2,  Re,8,   Sol, 8,
    Fa,6,   Mi,2,  Fa,16,

    Do,6,   Do,2,  Fa,12,  Fa,4,
    Sol,6,  Do,2,  La,8,   Fa,8,
    Fa,6,   Mi,2,  Re,8,   La, 8,
    La,6,   dSol,2,La,16,

    La,6,   Si,2,  DO,12,  La,4,
    Si,6,   DO,2,  RE,8,   Si,4,  Sol,4,
    Fa,6,   Re,2,  Do,8,   Fa,8,
    La,6,   Sol,2, Fa,18                         
};
</source>

Pentru a nu repeta la nesfarsit secventa de partitura, aceasta a fost cantata in sectiunea de setup - care este rulata numai o singura data la inceput:

<source lang="c">
void setup() {
    int octava=1; // puteti schimba cu 2,4,8 pentru a incerca alta octava - uneori se aude mai bine
    for (int nota_curenta = 0; nota_curenta < 46; nota_curenta++) 
    {
      tone(3, note[nota_curenta*2] * octava, 100*note[nota_curenta*2+1]); // 3 = pinul cu buzzer-ul, nota, delay
      delay(100*note[nota_curenta*2+1] + 100);
      noTone(3);
    }  
}
// modificarea octavei pentru a se auzi mai bine a fost observata de dl. Alexandru Ionita
</source>

== Utilizarea LED-urilor de pe Multifunctional Shield ==

Pe Shieldul Multifunctional aveti 4 leduri conectate la pinii 10,11,12,13. Fiind conectati direct la pinii mentionati, puteti sa ii aprindeti direct cu o comanda de tip digitalWrite. Un exemplu care aprinde pe rand LEDurile este urmatorul:
<source lang="c">
void setup() {
  pinMode(10,OUTPUT);
  pinMode(11,OUTPUT);
  pinMode(12,OUTPUT);
  pinMode(13,OUTPUT);
}

void loop() {  
  for(int i=10; i<14; i++)
     if(i-10 == millis()/300 % 4)
         digitalWrite(i,LOW);
     else    
         digitalWrite(i,HIGH);    
}
</source>

Dupa cum puteti observa daca rulati exemplul de mai sus, si aceste leduri functioneaza invers (la fel ca si display-ul numeric): se aprind cand le este setata valoarea LOW. In exemplul de mai sus, la fiecare trecere prin bucla for, este aprins doar un singur led - cel ce este setat pe LOW.

== Exercitii ==

====== Problema 1 (6pt) ======
Implementati:
* Pentru Lab. de Joi, 25.10.2018: IMNUL UNIRII, folosind partitura existenta [http://www.rador.ro/2016/05/25/portret-ciprian-porumbescu-o-viata-plina-de-cautari-bucurii-si-neimpliniri-curmata-mult-prea-devreme/ aici]
* Pentru Lab, de Vineri, 26.10.2018: Desteapta-te Romane, folosind partitura existenta [https://upload.wikimedia.org/wikipedia/commons/b/b6/National_Anthem_of_Romania_%28page_3%29.png aici] - doar primele 4 portative

====== Problema 2 (4pt) ======

Pentru Lab. de Joi, 25.10.2018:
Pe fiecare dintre cele 4 leduri conectate la pinii 10,11,12,13 faceti un efect de fade (fade in apoi fade out). Efectul trebuie sincronizat astfel incat cele 4 leduri sa fie shiftate in fadeul lor la un acelasi interval.
De exemplu, daca ledul 1 este la 100%, al doilea va fi la 50%, al treilea va fi la 0%, al patrulea va fi la 50%. La pasul urmator ledul 1 va fi 99%, ledul 2: 49%, ledul 3: 1%, ledul 4:51%....... etc.
Pont: nu toate ledurile de acolo sunt conectate la pini de tip PWM. Pentru a face fade unui led non-pwm va trebui mai degraba sa adaptati algoritmul ce va permitea sa setati un anumit voltaj unui pin (ultima problema din lab.2).


Pentru Lab, de Vineri, 26.10.2018:
Construiti un efect vizual folosind cele 4 leduri de pe shield, sincronizand efectele luminoase cu valorile notelor muzicale care urmeaza sa fie cantate astfel: 
* Vom considera cele 4 leduri ca o valoare numerica pe 4 biti pe care putem reprezenta valori intre 0 (0,0,0,0) si 15 (1,1,1,1).
* Pentru fiecare nota muzicala curenta, vom scrie pe aceste leduri, valoarea numerica data de restul impartirii notei, la 16 (nota%16)


====== Problema 3 (2pt - bonus - se pot lua numai dupa rezolvarea problemelor precedente) ======

Pentru Lab. de Joi, 25.10.2018:
Reprezentati in binar pe cele 4 leduri o cifra hexazecimala trimisa prin interfata seriala (cifrele in hexazecimal sunt 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F).


Pentru Lab, de Vineri, 26.10.2018:
Generati un numar random la startup intre 0 si 1000
Folosind consola Seriala, veti introduce numere intre 0 si 1000 incercand sa ghiciti acel numar random
Ledurile va vor ajuta sa va apropiati de numarul generat in felul urmator:
* toate ledurile stinse = foarte rece  (numarul introdus se afla la o distanta de minim 300 ca diferenta +- fata de valaorea reala)
* primul led aprins = cald             (numarul introdus se afla la o distanta de minim 100 ca diferenta +- fata de valaorea reala) 
* primele 2 leduri aprinse = fierbinte (numarul introdus se afla la o distanta de minim 30 ca diferenta +- fata de valaorea reala)
* toate ledurile aprinse = ati nimerit

https://pasteboard.co/IGvt7BH.png
