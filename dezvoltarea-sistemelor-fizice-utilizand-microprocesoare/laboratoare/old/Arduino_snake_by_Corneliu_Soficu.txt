Snake pentru Arduino cu ecran 16x2 LCD folosing libraria LiquidCrystal.h

Poate fi jucat clasicul joc Snake, varianta simpla, fara pereti. 
Dificultatea creste, marindu-se viteza snake-ului la fiecare punct obtinut. 
Jocul se opreste in momentul in care snake-ul se loveste de el insusi.

Pentru a muta snake-ul se folosesc butoanele de pe shield: UP, DOWN, LEFT, RIGHT
Daca acelasi buton este apasat de mai multe ori, directia snake-ului nu se va schimba.
Similar si daca se apasa un buton in directia opusa deplasarii snake-ului.

Pentru a prelua valoarea butonului, se folosesc intervale definite in cod, verificate cu output-ul
functiei analogRead();

Pentru a putea prelua corect valoarea butoanelor, trebuie modificate urmatoarele macro-uri 
in functie de configuratia ecranului folosit:

#define UP_BUTTON_LOWER_BOUND 1
#define UP_BUTTON_UPPER_BOUND 99

#define DOWN_BUTTON_LOWER_BOUND 100
#define DOWN_BUTTON_UPPER_BOUND 255

#define LEFT_BUTTON_LOWER_BOUND 256
#define LEFT_BUTTON_UPPER_BOUND 408

#define RIGHT_BUTTON_LOWER_BOUND 0
#define RIGHT_BUTTON_UPPER_BOUND 0

Acelasi lucru ar trebui facut si pentru macro-ul #define BUTTON A0 astfel incat sa fie specificat
pinul la care sunt conectate butoanele.

Inbunatatiri posibile:
* Debouncing la butoane;
* Mai multe niveluri posibile, ex: cu pereti;


<source lang="c">
/*
 * Made by Corneliu-Dumitru Soficu 
 * 06 November 2017
 */
#include <LiquidCrystal.h>

#define BUTTON A0

/* Liquid crystal configuration variables */
#define RS 8
#define ENABLE 9
#define D4 4
#define D5 5
#define D6 6
#define D7 7

#define BUTTON A0

/* Bounds for buttons analog read
 * Must be modified according to 
 * specific configuration
 */
#define UP_BUTTON_LOWER_BOUND 1
#define UP_BUTTON_UPPER_BOUND 99

#define DOWN_BUTTON_LOWER_BOUND 100
#define DOWN_BUTTON_UPPER_BOUND 255

#define LEFT_BUTTON_LOWER_BOUND 256
#define LEFT_BUTTON_UPPER_BOUND 408

#define RIGHT_BUTTON_LOWER_BOUND 0
#define RIGHT_BUTTON_UPPER_BOUND 0

/* Posibble directions for snake movement */
enum ButtonType
{
    up,
    down,
    left,
    right,
    none
};

LiquidCrystal lcd(RS, ENABLE, D4, D5, D6, D7);

int gameSpeed;
boolean gameOver;

/* Matrix used for each individual pixel representation */
boolean x[16][80];

/* Byte representation for a single row */
byte myChar[8];

/* Special flag used to print the snake or the food */
boolean special;

/* Current button input */
int btn;

/* Snake element representation using a simple linked list 
 * containing the row and col position in the 16 x 80 pixel matrix,
 * the direction of movement and the next body part of the snake.
 */
struct partdef
{
    int row, column, dir;
    struct partdef *next;
};
typedef partdef part;

/* Head and tail of snake */
part *head, *tail;

int i, j, collected = 0;

/* Coordinates for snake food */
long pc, pr;

/*  Function for creating a new food pixel */
void newPoint()
{

    part *p;
    p = tail;
    boolean newp = true;

    /* Generates random coordinates for the food pixel
   * until the first available one is found
   */
    while (newp)
    {
        pr = random(16);
        pc = random(80);
        newp = false;
        while (p->next != NULL && !newp)
        {
            if (p->row == pr && p->column == pc)
                newp = true;
            p = p->next;
        }
    }

    if (collected < 13)
    {
        growSnake();
    }
}

/* Draws the current state of the matrix at each loop() iteration */
void drawMatrix()
{

    /* Variable used for special character registration */
    int cc = 0;

    if (!gameOver)
    {
        /* Food pixel is turned on */
        x[pr][pc] = true;

        /* Each row */
        for (int r = 0; r < 2; r++)
        {   
            /* Each cell */
            for (int c = 0; c < 16; c++)
            {
                special = false;
                /* Each sub row */
                for (int i = 0; i < 8; i++)
                {
                    /* Byte representation of the pixel row in the cell */
                    byte b = B00000;

                    /* Checks for each sub column of the cell */
                    if (x[r * 8 + i][c * 5 + 0])
                    {
                        b += B10000;
                        special = true;
                    }
                    if (x[r * 8 + i][c * 5 + 1])
                    {
                        b += B01000;
                        special = true;
                    }
                    if (x[r * 8 + i][c * 5 + 2])
                    {
                        b += B00100;
                        special = true;
                    }
                    if (x[r * 8 + i][c * 5 + 3])
                    {
                        b += B00010;
                        special = true;
                    }
                    if (x[r * 8 + i][c * 5 + 4])
                    {
                        b += B00001;
                        special = true;
                    }
                    myChar[i] = b;


                }

                if (special)
                {
                    /* Registers the snake or food representation of the cell as a special character and prints it */
                    lcd.createChar(cc, myChar);
                    lcd.setCursor(c, r);
                    lcd.write(byte(cc));
                    cc++;
                }

                else
                {
                    /* Prints whitespace if there is not snake part or food in the cell */
                    lcd.setCursor(c, r);
                    lcd.print(' ');
                }
            }
        }
    }
}

/* Deletes the snake, used on game reset */
void freeList()
{
    part *p, *q;
    p = tail;
    while (p != NULL)
    {
        q = p;
        p = p->next;
        free(q);
    }
    head = tail = NULL;
}

/* Creates a new snake part, copies the tail data in the new node and assignes a new tail */ 
void growSnake()
{
    part *p;
    p = (part *)malloc(sizeof(part));
    p->row = tail->row;
    p->column = tail->column;
    p->dir = tail->dir;
    p->next = tail;
    tail = p;
}

/* Rewrites the matrix content according to the new snake direction */
void moveHead()
{
    /* Modifies the head row and column according to direction */
    switch (head->dir)
    {
    case up:
        head->row--;
        break;
    case down:
        head->row++;
        break;
    case right:
        head->column++;
        break;
    case left:
        head->column--;
        break;
    default:
        break;
    }

    /* At end of screen, snake goes to the other side */
    if (head->column >= 80)
        head->column = 0;
    if (head->column < 0)
        head->column = 79;
    if (head->row >= 16)
        head->row = 0;
    if (head->row < 0)
        head->row = 15;


    /* Checks for snake collision with itself */
    part *p;
    p = tail;
    while (p != head && !gameOver)
    {
        if (p->row == head->row && p->column == head->column)
            gameOver = true;
        p = p->next;
    }

    /* Updates the matrix snake representation */
    x[head->row][head->column] = true;

    /* Checks for snake eating the food */
    if (head->row == pr && head->column == pc)
    {
        collected++;
        if (gameSpeed < 25)
            gameSpeed += 3;
        newPoint();
    }
}

/* Moves the snake by updating the snake elements from tail to head */
void moveAll()
{
    part *p;
    p = tail;
    x[p->row][p->column] = false;
    while (p->next != NULL)
    {
        p->row = p->next->row;
        p->column = p->next->column;
        p->dir = p->next->dir;
        p = p->next;
    }
    moveHead();
}

/* Creates a custom sized snake, by allocating new nodes and linking them together */
void createSnake(int n) // n = size of snake
{
    for (i = 0; i < 16; i++)
        for (j = 0; j < 80; j++)
            x[i][j] = false;

    part *p, *q;
    tail = (part *)malloc(sizeof(part));

    /* Positions the snake at the 7th pixel row and starting from the 39th pixel column*/
    tail->row = 7;
    tail->column = 39 + n / 2;

    tail->dir = left;
    q = tail;
    x[tail->row][tail->column] = true;
    for (i = 0; i < n - 1; i++)
    {
        p = (part *)malloc(sizeof(part));
        p->row = q->row;
        p->column = q->column - 1;
        x[p->row][p->column] = true;
        p->dir = q->dir;
        q->next = p;
        q = p;
    }
    if (n > 1)
    {
        p->next = NULL;
        head = p;
    }
    else
    {
        tail->next = NULL;
        head = tail;
    }
}

/* Starts the game */
void startF()
{
    gameOver = false;
    gameSpeed = 3;
    freeList();
    createSnake(3);
    countDown(3);
}

/* Registers button press from the buttonBin from 4 multiplexed buttons */
int getButtonPress(int buttonPin)
{

    //TODO: Button Debouncing

    int sensorValue = analogRead(buttonPin);

    ButtonType btn = none;

    if (sensorValue >= UP_BUTTON_LOWER_BOUND && sensorValue <= UP_BUTTON_UPPER_BOUND)
    {
        btn = up;
    }

    else if (sensorValue >= DOWN_BUTTON_LOWER_BOUND && sensorValue <= DOWN_BUTTON_UPPER_BOUND)
    {
        btn = down;
    }

    else if (sensorValue >= LEFT_BUTTON_LOWER_BOUND && sensorValue <= LEFT_BUTTON_UPPER_BOUND)
    {
        btn = left;
    }

    else if (sensorValue >= RIGHT_BUTTON_LOWER_BOUND && sensorValue <= RIGHT_BUTTON_UPPER_BOUND)
    {
        btn = right;
    }

    return btn;
}

void setup()
{

    gameSpeed = 3;
    lcd.begin(16, 2);
    startF();
}

/* Simple countdown before game start or reset */
void countDown(int time)
{
    for (int i = time; i > 0; i--)
    {
        lcd.setCursor(7, 0);
        lcd.print(i);
        delay(1000);
    }
    lcd.clear();
}

/* Prints score and restores to initial state */
void resetGame()
{
    delay(3000);
    lcd.clear();
    lcd.home();
    lcd.print("Score: ");
    lcd.setCursor(7, 0);
    lcd.print(collected);
    delay(3000);
    lcd.clear();
    startF();
}

void loop()
{
    
    /* Registers button input and assignes new direction to snake head */
    btn = getButtonPress(BUTTON);
    if (btn != none)
    {
        if (btn == up && head->dir != down)
        {
            head->dir = up;
        }
        if (btn == down && head->dir != up)
        {
            head->dir = down;
        }
        if (btn == right && head->dir != left)
        {
            head->dir = right;
        }
        if (btn == left && head->dir != right)
        {
            head->dir = left;
        }
    }

    /* Delay used for game difficulty */
    delay(1000 / gameSpeed);

    moveAll();
    drawMatrix();

    if (gameOver)
    {
        resetGame();
    }
}
</source>
