<p>Cu totii stim ca de Sfintele Pasti sarbatorim invierea Domnului nostru Iisus Hristos. Totusi, ca sa se apropie si copiii de acest eveniment au fost atrasi printr-un iepuras care ascunde oua de ciocolata in diverse locuri din natura. </p>

<p>Cosminel este un hackeras care a reusit sa localizeze pe baza coordonatelor GPS toate oulele ascunse de iepuras in orasul sau. Avand aceste date stocate intr-o baza de date Oracle, Cosminel are foarte putin timp pentru a executa de 100 de ori o functie PLSQL care sa ii returneze numarul de oua de ciocolata ce se afla pe o raza de 0.05 grade GPS de punctul primit ca parametru.</p>

<ul>
<li> construiti o procedura prin intermediul careia sa scrieti intr-o tabela coordonatele GPS ale tuturor oualelor. Doua oua pot fi la aceeasi coordonata GPS si coordonatele GPS sunt date cu 4 zecimale (ex: lat = 12.4325 ; lng = 7.1642). Coordonatele GPS pot fi intre 0.0000 si 20.0000 (campurile tabelei "coordonate" vor fi "lat" si "lng"). Iepurasul a ascuns 10.000.000 de oua in orasul lui Cosminel, deci tabela coordonate va avea exact atatea inregistrari (10.000.000).</li>
<li> construiti o tabela "pozitii" avand campurile "lat" si "lng"; tabela pozitii va contine 100 coordonate, nu neaparat existente si in tabela coordonate.</li>
<li> construiti o functie care sa numere cate oua sunt intr-un cerc cu raza de 0.05 grade si cu centrul aflat intr-o anumita pozitie GPS (data prin lat+lng). Pentru a determina daca un punct P(a,b) se afla intr-un cerc C(r,x,y) puteti folosi teorema lui Pitagora: aflati distanata dintre cele doua puncte si daca este mai mica sau egala cu r atunci se afla in interiorul cercului (in principiu, daca radical((x-a)*(x-a) + (y-b)*(y-b)) <= r, atunci P(a,b) este un punct interior cercului C(r,x,y)). </li>
</ul>


<p>Afisati care este numarul de oua pentru fiecare pozitie data din tabelul "pozitii" (pe Cosminel il intereseaza in ce ordine sa atace aceste pozitii si de asta are nevoie de numarul de oua existente in acele zone).</p>


<p>Precizari: </p>

<ul>
<li> Cine doreste sa faca aceasta tema trebuie sa trimita la cosmin.varlan@gmail.com pana la data de 6 mai 2019 o functie  declarata astfel: "CREATE OR REPLACE FUNCTION numara_oua(lat number, lng number) RETURN INT".</li>
<li> Tema este "fiecare pentru el" (nu pe echipe, nu cu cod partajat).</li>
<li> Va exista un index creat astfel: "create index idx on coordonate(lat, lng);". Nici un alt index nu va mai fi disponibil si nici nu vi se va permite crearea de indecsi suplimentari.</li>
<li> Testul se va face prin executarea urmatorului select: "select lat, lng, numara_oua(lat, lng) from pozitii;"</li>
<li> Solutia voastra va fi acceptata de Cosminel doar daca functia va returna raspunsul corect intr-un timp mai mic ca a altor colegi (el va lua in considerare doar 10 solutii si daca timpii sunt asemanatori va pune cate 5 puncte fiecrui student). Cel care este pe locul 1 ca si timp va primi 10 puncte. Daca sunt mai multe probleme care au aproximativ acelasi timp de executie, doar primii 10 in ordinea ajungerii mailurilor vor primi punctele. Pentru a se estima timpul de executie al functiei dvs se vor face 5 teste si va fi luat timpul minim. Toate testele vor fi facute pe acelasi calculator - a lui Cosminel ;)</li>
<li> Script de creare / populare (s-ar putea sa aveti nevoie de un tablespace mai mare decat cel creat initial pentru utilizatorul student): https://pastebin.com/gtfsgRdX</li>
<li> Cosminel deja are un script care ruleaza in sub o secunda si nu accepta scripturi care sa depaseasca aceasta limita.</li>
</ul>


<p>Timpii vostri si corectitudinea rezolvarii:</p>

<ul>
<li> Guraliuc Iulian - 0.203 (raspuns corect) - </li>
<li> Vultur David - 0.180 (raspuns corect) - </li>
<li> Ciocoiu Razvan Andrei - 0.177 (raspuns corect) - </li>
<li> Palanici Bogdan - 0.218 (raspuns corect) - </li>
<li> Bujoreanu Vlad - 0.171 (raspuns corect) - </li>
<li> Traista Rafael - 0.188 (incorect)</li>
<li> Anechitoaie Beatrice - 0.219 (raspuns corect) - </li>
<li> Munteanu Andi - 0.203 (raspuns corect) - </li>
<li> Reftu Paul - 0.223 (corect) - </li>
<li> Agache Gabriel - 0.188 (corect) - </li>
<li> Istoc Bogdan - 0.188 (corect) - </li>
<li> Asoltanei Cristian - 0.184 (incorect)</li>
<li> Stavarache Antonio - 0.191 (corect) - </li>
<li> Bolota Stefan - 0.193 (incorect)</li>
<li> Botez Stefan - 0.198 (incorect)</li>
<li> Spinu Vasilica - depaseste 10 secunde</li>
<li> Dascalu Matei - 0.188 (corect) - </li>
<li> Cretu Marian - 0.198 (corect) -</li>
</ul>


<p>Primii 10 in ordinea timpilor (pentru cei cu timpi similari, sunt ordonati in ordinea sosirii emailurilor) ce vor primi 5 puncte sunt:</p>
<ul>
<li> Bujoreanu Vlad - 0.171 </li>
<li> Ciocoiu Razvan Andrei - 0.177 </li>
<li> Vultur David - 0.180 </li>
<li> Agache Gabriel - 0.188 </li>
<li> Istoc Bogdan - 0.188 </li>
<li> Dascalu Matei - 0.188 </li>
<li> Stavarache Antonio - 0.191 </li>
<li> Cretu Marian - 0.198 </li>
<li> Guraliuc Iulian - 0.203 </li>
<li> Munteanu Andi - 0.203 </li>
</ul>


<p>Codul cel mai rapid a fost cel al lui Vlad Bujoreanu (si pentru aceasta va primi 10 puncte). Acesta nu numai ca a folosit cum trebuie indexul, dar lui Cosminel i-a placut ca a sarit peste CBO spunandu-i din prima Querry Optimizer-ului sa foloseasca indexul printr-un hint in select. Va dau codul sau aici:</p>

<pre><code class="language-sql">CREATE OR REPLACE FUNCTION numara_oua(in_lat number, in_lng number) RETURN INT AS
  v_lat_sus coordonate.lat%type;
  v_lat_jos coordonate.lat%type;
  v_lng_stg coordonate.lng%type;
  v_lng_drp coordonate.lng%type;
  oua int;
BEGIN
  v_lat_sus := in_lat - 0.05; if (v_lat_sus < 0) then v_lat_sus := 0; end if;
  v_lat_jos := in_lat + 0.05; if (v_lat_jos > 20) then v_lat_jos := 20; end if;
  v_lng_stg := in_lng - 0.05; if (v_lng_stg < 0) then v_lng_stg := 0; end if;
  v_lng_drp := in_lng + 0.05; if (v_lng_drp > 20) then v_lng_drp := 20; end if;
  oua := 0;
  select /*+ INDEX(coordonate idx) */ count(*) into oua from (select /*+ INDEX(coordonate idx) */ lat, lng from (select /*+ INDEX(coordonate idx) */ lat, lng from coordonate where lat between v_lat_sus and v_lat_jos) where lng between v_lng_stg and v_lng_drp) where (lat - in_lat) * (lat - in_lat) + (lng - in_lng) * (lng - in_lng) <= 0.0025;
  return oua;
